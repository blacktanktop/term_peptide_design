# By Jiangang Chen 
# some modifications: including eef support and Ace support. 
# version 0.0.3

# To do list:
# (1) need to add more documentation
# (2) a clean support for the coordinates manipulation and analysis

package CHARMM;
#$DEF_VER_CONTROL->{ver}->{CHARMM} = "1.0";
$DEF_VER_CONTROL->{date}->{CHARMM} = "06/17/04";

use strict;
use GENERAL;
use PDB;
use DEFINITIONS;
use Text::Wrap;
use IPC::Open2;
use IO::Handle;
use IO::File;
use IO::Select;
use Scalar::Util;
use POSIX ":sys_wait_h";
use Time::HiRes qw (sleep);

=head2 

 Title   :  new 
 Usage   :  my $charmm = CHARMM::new("/usr/bin/charmm")
            my $charmm = CHARMM::new("/usr/bin/charmm", "script.inp", "script.out")
 Function:  CHARMM object constructor. A log file for CHARMM output and a command log file for commands
            sent to CHARMM may be given as an option. The constructor opens a connection to CHARMM and
            sets all parameters to default values.
 Returns :  none 
 Args    :  1. CHARMM executable to use
            2. Optional: input log file
            3. Optional: output log file
            4. Optional: flag. If set, output log file will not be deleted. Default is to delete.
            5. Optional: flag specifying whether an interactive CHARMM session is required. If yes,
               CHARMM code is directly printed to CHARMM (default). Otherwise, a CHARMM script is first
               created and then executed at the end.

=cut

sub new {
  my $self = {};
  my $exec = shift;
  my $logcmdfile = shift;
  my $logoutfile = shift;
  my $keepoutlog = shift;
  if (!defined($keepoutlog)) { $keepoutlog = 0; }
  my $inter = shift;
  $inter = 1 if (!defined($inter));
  if ($inter == 0 && !defined($logcmdfile)) {
    GENERAL::error("A command file is required for non-interactive CHARMM sessions!");
  }

  bless $self;
  $self->{handle}={};

  # read CHARMM parameters
  $self->{par} = GENERAL::LoadStruct(DEFINITIONS::getParmFile("CHARMM.param"), 1);
  $self->{inter} = $inter;

  # open script log file if necessary
  if (defined $logcmdfile) {
    $self->{handle}->{cmdlog} = GENERAL::GetOutFH($logcmdfile);
    $self->{handle}->{cmdlog}->autoflush(1);
    $self->{files}->{cmdlog} = $logcmdfile;
    if (!defined($logoutfile)) {
      $logoutfile = GENERAL::GetBase($logcmdfile) . ".out";
    }
  }

  if (!defined($logoutfile)) {
    if (defined($LOCAL_DEF)) {
      $logoutfile = "$LOCAL_DEF/.tmp_charmm$$".time().".out";
    } else {
      $logoutfile = ".tmp_charmm$$".time().".out";
    }
  }
  $self->{files}->{outlog} = $logoutfile;
  $self->{keepoutlog} = $keepoutlog;

  GENERAL::error("cannot execute CHARMM binary. $exec") if (!-x $exec);
  $self->{exec} = $exec;

  # set up writing streams for CHARMM
  if ($self->{inter}) {
    my $o2write = new IO::Handle;
    if (defined($SIG{CHLD})) { $self->{_prev_reaper} = $SIG{CHLD}; }
#    $SIG{CHLD} = \&GENERAL::REAPER;
#    $SIG{CHLD} = 'IGNORE'; # do not keep any zombies; if CHARMM unexpectedly, we will hopefully find out about it because writing to the pipe will fail
  #  $SIG{PIPE} = "IGNORE"; # ignore broken pipe signal - I want to trap this myself
    $self->{_charmmpid} = open($o2write, "| $exec &> $logoutfile") || GENERAL::error("open for $exec failed");
    $self->{handle}->{tocharmm} = $o2write;
  #  $self->{handle}->{tocharmm}->autoflush(1);
  } else {
    $self->{_charmmpid} = "non-interactive";
    $self->{handle}->{tocharmm} = $self->{handle}->{cmdlog};
  }
  $self->{_lastCommand} = "";
  $self->{_setup} = 0;
  $self->{_pdb} = undef;

  # send title to begin script
  my $date = GENERAL::GetTime();
  my $mac = GENERAL::GetMachine();
  my $dir = GENERAL::GetDir();
  $self->send(Text::Wrap::wrap("* ", "* ", "CHARMM script Generated by PROCEDE Package\nDate: $date, machine: $mac, directory: $dir")."\n*\n");
  $self->{machine} = $mac;

  # for backwards compatibility make $self->{files}->{inp} point to the CHARMM object
  # itself and provide methods print and printf such that all old calls of the form
  # $self->{files}->{inp}->print... and $self->{files}->{inp}->printf still work.
  $self->{files}->{inp} = $self;
  Scalar::Util::weaken($self->{files}->{inp}); # need to weaken reference to avoid memory leak

  return $self;
}


DESTROY {
  my $self = shift;
  
  $self->finish() if (!defined $self->{_finished} || !$self->{_finished});
  if ($self->{inter}) {
    if (defined($self->{_prev_reaper})) { $SIG{CHLD} = $self->{_prev_reaper}; }
    else { delete($SIG{CHLD}); }
  }
}


=head2

 Title   :  send
 Usage   :  $charmm->send("ic paral all");
 Function:  Runs an arbitrary CHARMM command. Please note, that for commands requiring
            multiple lines all lines have to be given at once as a single argument.
 Returns :  String or a list of strings (which will be concatenated) containing the command(s).
 Args    :  1. String

=cut

sub send {
  my $self = shift;
  my $txt = join("",@_);
  if ($self->{inter}) {
    # See if CHARMM is still alive
    if ((kill 0, $self->{_charmmpid}) != 1 || ($self->{handle}->{tocharmm}->error())) {
      $self->error("CHARMM died unexpectedly.");
    }
  }

  $self->{handle}->{tocharmm}->print("$txt");
  $self->{handle}->{cmdlog}->print("$txt") if ($self->{inter} && defined($self->{handle}->{cmdlog}));
}


sub _write {
  my $self = shift;
  my $txt = shift;

#print "LINE [$txt]\n";
  $self->{handle}->{cmdlog}->print("$txt") if ($self->{inter} && defined($self->{handle}->{cmdlog}));
  $self->{handle}->{tocharmm}->print("$txt");
}


=head2

 Title   :  flush
 Usage   :  $charmm->flush();
 Function:  Flushes CHARMM output streams.
 Returns :  Nothing
 Args    :  

=cut

sub flush {
  my $self = shift;
  # See if CHARMM is still alive
  if ($self->{inter}) {
    if ((kill 0, $self->{_charmmpid}) != 1 || ($self->{handle}->{tocharmm}->error())) {
      $self->error("CHARMM died unexpectedly.");
    }
  }
  $self->{handle}->{tocharmm}->flush();
  $self->{handle}->{cmdlog}->flush() if ($self->{inter} && defined($self->{handle}->{cmdlog}));
}


=head2

 Title   :  _closeAll
 Usage   :  $charmm->_closeAll();
 Function:  Closes all handles, waits until CHARMM terminates and returns.
 Returns :  Nothing
 Args    :  None.

=cut

sub _closeAll {
  my $self = shift;

  close $self->{handle}->{tocharmm};

  if ($self->{inter}) { waitpid($self->{_charmmpid}, 0); }

  undef $self->{handle}->{cmdlog} if (defined $self->{handle}->{cmdlog});
  undef $self->{handle}->{outlog} if (defined $self->{handle}->{outlog});
}


=head2

 Title   :  finish
 Usage   :  $charmm->finish();
 Function:  Stops CHARMM and closes the connection and all log files. After this function
            has been called CHARMM commands can no longer be used. It is called automatically
            by the package destructor if it has not called explicitly.
 Returns :  Nothing
 Args    :  None.

=cut

sub finish {
  my $self = shift;
  my $doNotRun = shift;
  $doNotRun = 0 if (!defined($doNotRun));

  $self->send("stop\n");

  # close all file handles
  $self->_closeAll();

  # run unless not supposed to
  if (!$doNotRun) {
    if ($self->{inter} == 0) {
      GENERAL::csystem("$self->{exec} < $self->{files}->{cmdlog} &> $self->{files}->{outlog}");
    }
  
    # clean up files
    if (defined($self->{files}->{outlog})) {
      my $err = `grep -i \"abnormal termination\" $self->{files}->{outlog}`;
      chomp($err);
      if ($err =~ /\S/) {
        $self->error("CHARMM failed: abnormal termination message found in output.");
      }
      GENERAL::crm($self->{files}->{outlog}) unless ($self->{keepoutlog});
    }
  }

  $self->{_finished} = 1;
}

sub error {
  my $self = shift;
  my $msg = shift;

  $self->_closeAll();
  if (defined($self->{files}->{cmdlog})) { $msg .= " Input in $self->{files}->{cmdlog}."; }
  if (defined($self->{files}->{outlog})) { $msg .= " Output in $self->{files}->{outlog}."; }
  $self->{_finished} = 1;
  GENERAL::error($msg);
}

=head2   endofstory

 Title   :  endofstory
 Usage   :  $charmmobj->endofstory()
 Function:  Same as CHARMM::finish(). Exists for backwards compatibility.
 Returns :  none
 Args    :  none

=cut

sub endofstory  {
  my $self = shift;
  $self->finish();
}



=head2   print

 Title   :  print
 Usage   :  $charmmobj->print()
 Function:  Same as send - for backwards compatibility.
 Returns :  
 Args    :  

=cut

sub print {
  my $self = shift;
  my $txt = shift;

  $self->send($txt);
}


=head2   printf

 Title   :  printf
 Usage   :  $charmmobj->printf()
 Function:  The same as CHARMM::print(), but accepts printf formatted type input. I.e.
            one can say $charmm->printf("inte select atom %c %d * end select all end", $chain, $iresnum)
 Returns :  
 Args    :  

=cut

sub printf {
  my $self = shift;
  my $txt = "";
  if (scalar(@_) == 1) { $txt = sprintf($_[0]); }
  elsif (scalar(@_) > 1) { $txt = sprintf($_[0], @_[1 .. scalar(@_)-1]); }

  $self->send($txt);
}

=head2

 Title   :  verbose
 Usage   :  $charmm->verbose("ic paral all");
 Function:  The same thing as print - exists for backwards compatibility.
 Args    :  1. String

=cut

sub verbose {
  my $self = shift;
  my $txt = join("",@_);

  $self->send("$txt\n");
}


sub runCharmm {
  GENERAL::warning("Tried to use a depricated function - please remove this statement!");
}


=head2

 Title   :  wait
 Usage   :  $charmm->wait();
 Function:  Waits until CHARMM executes all of the commands in its buffer and returns.
            This is done through asking CHARMM to write something to disk and waiting
            for that file. Admittedly this is not a great mechanism, but it is simple,
            does not require setting up complicated input/output stream scenarious and
            avoids the possibility of deadlock.
 Returns :  Nothing
 Args    :  1. Optional: directory where the temp file will be created. Convenient for
               specifying a local dir. Otherwise, the current dir is used.

=cut

sub wait {
  my $self = shift;
  my $dir = shift;
  if (!defined($dir)) { $dir = "./"; }
  my $sleep_int = shift; $sleep_int = 1 if (!defined($sleep_int));
  my $att = shift; $att = 60 if (!defined($att));
  my $warn_f = shift; $warn_f = 1 if (!defined($warn_f));
  $self->{machine} = GENERAL::GetMachine() if (!defined($self->{machine}));

  if ($self->{inter} == 0) { GENERAL::error("A wait is not possible in a non-interactive session!"); }

  my $file = "$dir/123_charmm_wait_tmp_$$.$self->{machine}.out";
  if (-e $file) { GENERAL::crm($file); }
  $self->verbose("open write unit 88 card name \"$file\"\nwrite title unit 88\n* COMPLETE\n*\nclose unit 88\n");
  $self->flush();
  my $t = time();
  while (1) {
    for (my $i = 1; $i <= $att; $i++) {
      if (-e $file) { GENERAL::crm($file); return; }
      sleep($sleep_int);
    }
    $self->send("\n\n\n\n"); # dummy print to cause process check
    GENERAL::warning("Have been waiting for CHARMM for " . (time() - $t) ." seconds. Return from kill 0 is " . (kill 0, $self->{_charmmpid}) . ". CHARMM pid is $self->{_charmmpid}.") if ($warn_f);
    GENERAL::REAPER();
  }
}


=head2    loadParm
 
 Title   :  loadParm
 Usage   :  $charmmobj->loadParm('scaled')
 Function:  CHARMM load topology and parameter files into CHARMM.
            This should be called as one of the first CHARMM.
            commands before any structures are loaded.
            Depending on the parameter CHARMM19, scaled CHARMM19
            or CHARMM22 parameters are loaded. The parameter may
            be set through a hash-type key=>value pair argument.
 Returns :  none
 Args    :  1. Type of parameter file (scaled radii, EEF, ...)

=cut

sub loadParm {

    my $self = shift;
    my $switch = shift;
    if (!defined($switch)) { $switch = ""; }
    $switch = uc($switch);

    my ($topfile,$parfile);
    my $patchtopfile; my $hbondpar = undef;

    if ($self->{par}->{param} eq '19') {
      if ($switch =~ /SCALED/) {
        $topfile = DEFINITIONS::getParmFile("toph19.inp");
        $parfile = DEFINITIONS::getParmFile("param19_90.inp");
        $patchtopfile = DEFINITIONS::getParmFile("patchtop19.inp");
      } elsif ($switch eq "EEF1") {
        $topfile = DEFINITIONS::getParmFile("toph19_eef1.inp");
        $parfile = DEFINITIONS::getParmFile("param19_eef1.inp");
        $patchtopfile = DEFINITIONS::getParmFile("patchtop19_eef1.inp");
      } elsif ($switch eq "EEF1.1") {
        $topfile = DEFINITIONS::getParmFile("toph19_eef1.1.inp");
        $parfile = DEFINITIONS::getParmFile("param19_eef1.1.inp");
        $patchtopfile = DEFINITIONS::getParmFile("patchtop19_eef1.1.inp");
      } elsif ($switch =~ /IMM1/) {
        $topfile = DEFINITIONS::getParmFile("toph19_eef1.1.inp");
        $parfile = DEFINITIONS::getParmFile("param19_eef1.1.inp");
        $patchtopfile = DEFINITIONS::getParmFile("patchtop19_eef1.1.inp");
      } elsif ($switch =~ /ACE/) {
        $topfile = DEFINITIONS::getParmFile("toph19.inp");
        $parfile = DEFINITIONS::getParmFile("param19_ace.inp");
      } else {
        $topfile = DEFINITIONS::getParmFile("toph19.inp");
        $parfile = DEFINITIONS::getParmFile("param19.inp");
        $patchtopfile = DEFINITIONS::getParmFile("patchtop19.inp");
      }
      if ($switch =~ /HBON/) {
        $hbondpar = DEFINITIONS::getParmFile("par_hbond.inp");
      }
    } elsif ($self->{par}->{param} eq '22') {
      if ($switch eq "EEF1") {
        $topfile = DEFINITIONS::getParmFile("top_all22_prot_eef1.inp");
        $parfile = DEFINITIONS::getParmFile("par_all22_prot.inp");
      } elsif ($switch eq "EEF1.1") {
        $topfile = DEFINITIONS::getParmFile("top_all22_prot_eef1.1.inp");
        $parfile = DEFINITIONS::getParmFile("par_all22_prot.inp");
      } else {
        $topfile = DEFINITIONS::getParmFile("top_all22_prot.inp");
        $parfile = DEFINITIONS::getParmFile("par_all22_prot.inp");
      }
    } elsif ($self->{par}->{param} eq 'CRICK') {
      $topfile = DEFINITIONS::getParmFile("toph19_crick.inp");
      $parfile = DEFINITIONS::getParmFile("param19_crick.inp");
      $patchtopfile = DEFINITIONS::getParmFile("patchtop19.inp");
    } else {
      GENERAL::error("Unanticipated combination of parameter values (\"$self->{par}->{param}\" and \"$switch\")!");
    }

    my $fhandle = $self->{files}->{inp};
    $fhandle->print("prnlev $self->{par}->{prnlev}\n");
    $fhandle->print("wrnlev -1\n");
    $fhandle->print("bomlev -2\n\n");
    $fhandle->print("open read unit 10 card name \"$topfile\"\n");
    $fhandle->print("read rtf card unit 10\n");
    $fhandle->print("close unit 10\n\n");
    if (defined($patchtopfile)) {
      $fhandle->print("open read unit 10 card name \"$patchtopfile\"\n");
      $fhandle->print("read rtf append card unit 10\n");
      $fhandle->print("close unit 10\n\n");
    }
    $fhandle->print("open read unit 10 card name \"$parfile\"\n");
    $fhandle->print("read para card unit 10\n");
    $fhandle->print("close unit 10\n\n");
    if (defined($hbondpar)) {
      $fhandle->print("open read unit 10 card name \"$hbondpar\"\n");
      $fhandle->print("read para append card unit 10\n");
      $fhandle->print("close unit 10\n\n");
    }
#    $fhandle->print("bomlev -1 \n\n");

    return ('par', $parfile, 'top', $topfile, 'patch', $patchtopfile, 'hbond', $hbondpar);
}



=head2    loadPairParm

 Title   :  loadPairParm
 Usage   :  $charmmobj->loadPairParm('param', 'scaled')
 Function:  CHARMM load topology and parameter files into CHARMM.
            This should be called as one of the first CHARMM.
            commands before any structures are loaded.
            Depending on the parameter CHARMM19, scaled CHARMM19
            or CHARMM22 parameters are loaded. The parameter may
            be set through a hash-type key=>value pair argument.
 Returns :
 Args    :  version of charmm parameter files

=cut

sub loadPairParm {

    my $self = shift;
    my $switch = shift;
    if (!defined($switch)) { $switch = ""; }
    $switch = uc($switch);

    my ($topfile, $parfile);  my $hbondpar = undef;
    if ($self->{par}->{param} eq '19') {
      if ($switch =~ /SCALED/) {
        $topfile = DEFINITIONS::getParmFile("toph19.inp");
        $parfile = DEFINITIONS::getParmFile("param19_90.inp");
      } elsif ($switch =~ /EEF1/) {
        $topfile = DEFINITIONS::getParmFile("toph19_eef1.inp");
        $parfile = DEFINITIONS::getParmFile("param19_eef1.inp");
      } elsif ($switch =~ /ACE/) {
        $topfile = DEFINITIONS::getParmFile("toph19.inp");
        $parfile = DEFINITIONS::getParmFile("param19_ace.inp");
      } else {
        $topfile = DEFINITIONS::getParmFile("toph19.inp");
        $parfile = DEFINITIONS::getParmFile("param19.inp");
      }
      if ($switch =~ /HBON/) {
        $hbondpar = DEFINITIONS::getParmFile("par_hbond.inp");
      }
    } elsif ($self->{par}->{param} eq '22') {
      $topfile = DEFINITIONS::getParmFile("top_all22_prot.inp");
      $parfile = DEFINITIONS::getParmFile("par_all22_prot.inp");
    } else {
      GENERAL::error("Unanticipated combination of parameter values (\"$self->{par}->{param}\" and \"$switch\")!");
    }

    my $fhandle = $self->{files}->{inp};
    $fhandle->print("prnlev $self->{par}->{prnlev}\n");
    $fhandle->print("wrnlev -1\n");
    $fhandle->print("bomlev -2\n\n");
    $fhandle->print("open read unit 10 card name \"$topfile\"  \n");
    $fhandle->print("read rtf card unit 10  \n");
    $fhandle->print("close unit 10  \n\n\n");
    $fhandle->print("open read unit 10 card name \"$parfile\"  \n");
    $fhandle->print("read para card unit 10  \n");
    $fhandle->print("close unit 10  \n\n\n");
    if (defined($hbondpar)) {
      $fhandle->print("open read unit 10 card name \"$hbondpar\"\n");
      $fhandle->print("read para append card unit 10\n");
      $fhandle->print("close unit 10\n\n");
    }
#    $fhandle->print("bomlev -1 \n\n");
}


=head2  setupFromPDB 

 Title   :  setupFromPDB 
 Usage   :  $charmm->setupFromPDB('blah.pdb')
 Function:  generates the CHARMM PSF structure from a protein 
            structure in a PDB file. It also rebuilds missing 
            atoms and adds hydrogens, if necessary. The type 
            of terminal groups may be selected through the second
            argument. Possible options are <mark>none</mark>, 
            <mark>ends</mark>, and <mark>all</mark>.
 Returns :  none
 Args    :  (1) pdb file 
            (2) terminal bit (optional): default is none
                 it could be set up as BLOCK to set 
                    first res as AMN 
                    last res as CBX
=cut


sub setupFromPDB {

  my $self = shift;
  my $pdbfile = shift;
  my $terminal = shift;
  my $fhandle = $self->{files}->{inp};
  my $prefix = GENERAL::GetBase($pdbfile);

  my $pdb=PDB::new($pdbfile);
  $self->{_pdb}=$pdb;

  my $clist = $pdb->{pickedchains};

  $terminal = "none" unless (defined $terminal);

  for (my $i=0; $i<=$#{$clist}; $i++) {
    my $first="";
    my $last="";
    my $c=$clist->[$i];

    if ($terminal eq "none") {
        $first="firs none";
        $last="last none";
    } elsif (uc($terminal) eq "BLOCK") {
        $first="firs AMN";
        $last="last CBX";
    }

    # here we generate a temp file for each chain

    my $fname = $prefix.'_'."$c->{id}".'.pdb';
    # $pdb->writePDB($fname,"CHARMM"."$self->{par}->{param}".'nohrenum',$c->{id});
    $pdb->writePDB($fname,"genericnohrenum", $c->{id});
    # here we setup the squence reading
    $fhandle->print("open unit 10 read form name \"$fname\"  \n");
    $fhandle->print("read sequ pdb unit 10  \n");
    $fhandle->print("generate $first $last $c->{id} setup warn \n");
    $fhandle->print("close unit 10  \n\n");
  }



  foreach my $c ( @{$clist} ) {
    my $fname = "$prefix".'_'.$c->{id}.'.pdb';

    # now read in  the coords
    $fhandle->print("open unit 10 read form name \"$fname\"  \n");
    $fhandle->print("read coor pdb unit 10 resi  \n");
    $fhandle->print("close unit 10  \n\n");
  }


  $fhandle->print("print coor select .not. \(hydrogen .or init\) end \n");
  $fhandle->print("ic param all\n");

  $self->{_setup} = 1;
}



=head2  setupFromCRD

 Title   :  setupFromCRD 
 Usage   :  $charmm->setupFromCRD($crdfile, $hbondflag, $terminal);
            where $hbondflag =0 (off) 1 (on) 
                  $terminal  = 'TER'  or 'NONE';
 Function:  generates the CHARMM PSF structure from a protein 
            structure in a CRD file. It also rebuilds missing 
            atoms and adds hydrogens, if necessary. The type 
            of terminal groups may be selected through the second
            argument. Possible options are <mark>none</mark>, 
            <mark>ends</mark>, and <mark>all</mark>.
 Returns :  Number of residues read in.
 Args    :  (1) crd file name
            (2) terminal bit (optional)    
=cut


sub setupFromCRD {

  my $self=shift;
  my $crdfile=shift;
#  my $hbondflag=shift;
  my $terminal=shift;
  my $patches = shift;
  my $fhandle=$self->{files}->{inp};

  my $crd = PDB::new($crdfile);
  $self->{_crd}=$crd;

  my $clist=$crd->{pickedchains};
  my $seq_length = 0;

#  if (!defined  $hbondflag) {
#    die "Error in setupFromCRD: h-bond flag is not defined!\n";
#  }

  $terminal = "none" unless (defined $terminal);

  for (my $i=0; $i<=$#{$clist}; $i++) {
    my $first="";
    my $last="";
    my $c=$clist->[$i];

    if ($terminal eq "none") {
      $first="firs none";
      $last="last none";
    } elsif ( uc($terminal) =~ /^\s*TER\s*$/) {
      $first="firs nter";
      $last="last cter";
    } elsif (ref($terminal) eq "ARRAY") {
      $first = $terminal->[$i];
      $last = "";
    } else {
      $first=$terminal;
      $last="";
    }
    # here we setup the squence reading
    $fhandle->print("!now read in the sequence information\n");

    if ($c->{id} =~ /SOL/ ) {
    my $num= $#{$c->{res}}+1;
      $fhandle->print("read sequence TIP3 $num\n*\n");
      $fhandle->print("generate SOLV noangle nodihedral \n\n");
    } else {
      $fhandle->print("read sequence card\n*\n");
      # now prepare the squence list, loop over the residue list
      my @seq;
      # calculate total residue number in that chain
      my $resnum = $#{$c->{res}}+1;

      foreach my $r (@{$c->{res}}) {
        push (@seq, $r->{resname});
      }
      $fhandle->print("$resnum\n");
      my $k=0;
      for (my $i=0; $i<=$#seq; $i++) {
        $fhandle->print("$seq[$i] ");
        $k++;
        # every line inlcudes 15 residues
        if ($k == 15) {
          $fhandle->print("\n");
          $k=0;
        }
      }
      $fhandle->print("\n");
      $fhandle->print("generate $c->{id} $first $last setup warn \n\n");
      $seq_length += $resnum;
    }
  }

  # some stupid bomlev
  $fhandle->print("bomlev -2\n");

  if (defined($patches)) {
    foreach my $patch (@{$patches}) {
      $self->send("patch $patch->{pname} $patch->{cid} $patch->{resid} setup\nautogenerate angles\n");
    }
    $self->send("ic param all\n");
  }

  # now read in coordinate
  $fhandle->print("open read unit 77 card name \"$crdfile\"  \n");
  $fhandle->print("read coor card resid unit 77  \n");
  $fhandle->print("close unit 77  \n\n");

  $fhandle->print("!print coor select .not. \(hydrogen .or init\) end \n");
  $fhandle->print("ic param all\n");
#  $fhandle->print("hbuild\n") if ($hbondflag);
  $self->{_setup}=1;

  return $seq_length;
}





=head2  readFromPDB

 Title   :  readFromPDB
 Usage   :  $charmmobj->readFromPDB(pdbfile)
 Function:  reads coordinates for a protein structure from a 
            PDB file if the PSF was setup before with setupFromPDB.
            This is useful for repeating a modeling procedure 
            for different conformations of the same protein.
            As setupFromPDB, this method also rebuilds
            missing atoms and adds hydrogens if necessary. 
 Returns :  none
 Args    :  pdb file name

=cut


sub readFromPDB {

  my $self=shift;
  my $fhandle=$self->{files}->{inp};
  my $pdbfile=shift;

  die "need to setup protein structure first"
    if (!defined $self->{_pdb});

  my $pdb=PDB::new($pdbfile);

  my $random = int(rand(81)) + 20;
  my $fname = 'temp_'."$random".'.pdb';
  $pdb->writePDB($fname,"CHARMM".$self->{par}->{param}."nohrenum");

  $fhandle->print("open unit 10 read form name \"$fname\"  \n");
  $fhandle->print("read coor pdb unit 10 resi  \n");
  $fhandle->print("close unit 10  \n\n");

  $fhandle->print("print coor select .not. \(hydrogen .or init\) end \n");
  $fhandle->print("ic param all\n\n");

  &GENERAL::Remove($fname);
}



=head2  setPairSequence 

 Title   :  setPairSequence()
 Usage   :  $charmmobj->setPairSequence()
 Function:  setup sequence card for pairwise eef charmm calculation
 Returns :  none
 Args    :  (1) residue name
            (2) chain id 
            (3) flag - if set, backbone will not be deleted. Default is to delete.

=cut

sub setPairSequence {
  my $self = shift;
  my $resname1 = shift;
  my $chain = shift;
  my $nodel = shift;

  my $fhandle = $self->{files}->{inp};
  $fhandle->print("\n! Generate topology of each segment \n");
  $fhandle->print("! ================================= \n");
  $fhandle->print("read sequence card\n*\n1\n$resname1\n\n");
  $fhandle->print("generate $chain first none last none setup\n");
  unless (defined($nodel) && $nodel) { $fhandle->print("delete atom select " . CHARMM::backbone() . " end\n\n"); }
#  $fhandle->print("delete atom select type N .or. type H .or. type CA .or. type HA - \n");
#  $fhandle->print("                   .or. type C .or. type O end\n\n\n");
}


=head2  setSequence

 Title   :  setPairSequence()
 Usage   :  $charmmobj->setPairSequence()
 Function:  setup a sequence card
 Returns :  none
 Args    :  (1) residue name
            (2) chain id

=cut
sub setSequence {

  my $self=shift;
  my $fhandle=$self->{files}->{inp};
  my $resname1=shift;
  my $chain=shift;

  $fhandle->print("\n! Generate topology of each segment \n");
  $fhandle->print("! ================================= \n");
  $fhandle->print("read sequence card\n*\n1\n$resname1\n");
  $fhandle->print("generate $chain first none last none setup\n");
}


=head2  backbone

 Title   :  backbone()
 Usage   :  CHARMM::backbone()
 Function:  Returns the definition of backbone in CHARMM
 Returns :  Returns the definition of backbone in CHARMM
 Args    :  1. string swtich
                - if contains "WATER", water molecules will also be
                  included in the backbone.
=cut

sub backbone {
  my $switch = shift;
  if (!defined($switch)) { $switch = ""; }
  my @bba;
  if ($switch =~ /WAT/) {
    @bba = PDB::backboneA("WATER");
  } else {
    @bba = PDB::backboneA("");
  }

  my $bckbn = "type " . join(" .or. type ", @bba);
  $bckbn = wrap("", "", $bckbn);
  $bckbn =~ s/\n/ -\n/g;
  return $bckbn;
}

=head2  initCoord

 Title   :  initCoord()  
 Usage   :  $charmmobj->initCoord() 
 Function:  initializes all coordinates
 Returns :  none
 Args    :  none

=cut

sub initCoordinates {

  my $self=shift;  
  $self->{files}->{inp}->print("coor init select all end \n");
}


=head2   setupNonBonded

 Title   :  setupNonBonded
 Usage   :  $charmmobj->setupNonBonded()
 Function:  calls the CHARMM command update 
            to set non-bonded interaction parameters. 
            Options are constant (dielec=>"CDIE") or 
            distance-dependent dielectric (dielec=>"RDIE"),
            the dieletric constant epsilon and interaction
            and list cutoffs (cutnb, cuton, cutoff).
            Force shifting is set for electrostatics as well
            as van der Waals interactions as the default
            for vacuum minimizations.
 Example :  Here is the update we will use in the calculations
 Returns :  none
 Args    :  none

=cut

sub setupNonBonded {
    my $self=shift;
    $self->_getpar(@_);
    $self->{files}->{inp}->print("update $self->{par}->{dielec} eps $self->{par}->{rdie} cutnb $self->{par}->{cutnb} - \n");
    $self->{files}->{inp}->print("       ctofnb  $self->{par}->{cutoff} ctonnb $self->{par}->{cuton} shift vshift - \n");
    $self->{files}->{inp}->print("update inbfrq 0 ihbfrq 0 \n\n");        
}


=head2

 Title   :  setupEEF1
 Usage   :  $charmm->setupeef1();
 Function:  setup eef calculation
 Returns :  none
 Args    :  (1) 0:  use original karplus eef parm
            (2) 1:  use hand modified eef parm
            (3) 2:  use customized eef parm.
            if argument is 2, the file with full path must be provided as
            the second argument

=cut

sub setupEEF1 {

    my $self = shift;
    my $fhandle = $self->{files}->{inp};
    my $useold = shift;
    $useold = 1 if (!defined $useold);
    my $ctonnb = shift; if (!defined($ctonnb)) { $ctonnb = 7.0 }
    my $ctofnb = shift; if (!defined($ctofnb)) { $ctofnb = 9.0 }
    my $cutnb = shift; if (!defined($cutnb)) { $cutnb = 10.0 }
    my $first = shift; if (!defined($first)) { $first = 1; }

    my $solvpar;
    if ($useold == 1) {
       $solvpar = DEFINITIONS::getParmFile(($self->{par}->{param} eq 22) ? "solvpar22.inp" : "solvpar.inp");
    } elsif ($useold == 0) {
       $solvpar = DEFINITIONS::getParmFile("solvpar_orig.inp");
    }  elsif ($useold == 2)  {
       $solvpar = DEFINITIONS::getParmFile(shift);
    } else {
      die "Error in CHARMM::setupEEF1: unanticipated value of useold (\"$useold\")!\n";
    }
#    GENERAL::GLog("Using solvation parameter file \"$solvpar\" for initializing EEF1 in CHARMM");

#    $fhandle->print("\n", '! IMPLICIT SOLVATION SETUP COMMAND',  "\n");
#    $fhandle->print('! The nonbonded options below are part of the model',  "\n");
#    $fhandle->print(  "\n");
    $fhandle->print("eef1 setup temp $self->{par}->{eef_temp} unit 93 name \"$solvpar\"\n") if ($first);
#    $fhandle->print("update ctonnb $self->{par}->{eef_ctonnb} ctofnb $self->{par}->{eef_ctofnb} cutnb $self->{par}->{eef_cutnb} group rdie",  "\n\n");
    $fhandle->print("update ctonnb $ctonnb ctofnb $ctofnb cutnb $cutnb group rdie\n");
}



=head2

 Title   :  setupIMM1
 Usage   :  $charmm->setupIMM1(30.0);
 Function:  setup IMM1 model
 Returns :  none
 Args    :  (1) membrane thickness

=cut

sub setupIMM1 {
  my $self = shift;
  my $mwidth = shift;
  $mwidth = $self->{par}->{imm1_mwidth} if (!defined($mwidth));

  $self->send("eef1 setup membrane slvt water slv2 chex nsmth 10 width $mwidth temp $self->{par}->{eef_temp} -\n");
  $self->send("unit 93 name \"" . (DEFINITIONS::getParmFile("solvpar_imm1.inp")) . "\" aemp 0.85\n");
#  $self->send("update ctonnb 7. ctofnb 9. cutnb 10. group rdie\n");
  $self->send("update ctonnb 7. ctofnb 9. cutnb 10."); $self->send(" group rdie") if ($self->{par}->{param} ne 22);
  $self->send("\n");
}

=head2

 Title   :  loadImageFile
 Usage   :  $charmm->loadImageFile("C2.sym");
 Function:  Loads an image file for use with the IMAGE facility in CHARMM.
 Returns :  none
 Args    :  (1) image file name

=cut

sub loadImageFile {
  my $self = shift;
  my $imfile = shift;

  $self->send("open read unit 77 card name \"$imfile\"\n");
  $self->send("read image unit 77 init print\n");
  $self->send("close unit 77\n");
  $self->send("update IMGFrq -1\n\n");
}

=head2   setupMulteNonBonded

 Title   :  setupMulteNonBonded
 Usage   :  $charmmobj->setupDesignNonBonded()
 Function:  calls the CHARMM command update 
            to set non-bonded interaction parameters.             
 Example :  Here is the update we will use in the calculations
    
    atom rdiel switch eps 4.0 e14fac 0.4 -
    cutnb 999.0 ctonnb 997.0 ctofnb 998.0 -
    nbxmod 5 vswitch wmin 1.5 vatom vdistance
    update inbfrq 0 ihbfrq 0

 Returns :  none
 Args    :  hond flag optional

=cut

sub setupMulteNonBonded {
    my $self = shift;
    my $hbondflag = shift;
    $hbondflag = 0 if (!defined $hbondflag);
    my $rdie = shift;
    $rdie = $self->{par}->{rdie} if (!defined($rdie));

#    if ($hbondflag) {
#      $self->{files}->{inp}->print("update ihbfrq 1 NOACCEPTORS HBNOEXCLUSIONS ALL ctonhb $self->{par}->{ctonhb} ctofhb $self->{par}->{ctofhb} cuthb $self->{par}->{cuthb} ctonha $self->{par}->{ctonha} -\n");
#      $self->{files}->{inp}->print("      ctofha $self->{par}->{ctofha} cuthba $self->{par}->{cuthba}\n");
#    }

#    # This update line has to be here, otherwise it crashes - ??? Gevorg
    $self->{files}->{inp}->print("update inbfrq -1 -\n");
    $self->{files}->{inp}->print("       atom rdie switch eps $rdie e14fac $self->{par}->{e14fac}  cutnb $self->{par}->{cutnb} - \n");
    $self->{files}->{inp}->print("       ctofnb  $self->{par}->{ctofnb} ctonnb $self->{par}->{ctonnb} nbxmod $self->{par}->{nbxmod} vswitch wmin $self->{par}->{wmin} vatom vdistance\n");
#    $self->{files}->{inp}->print("update inbfrq $self->{par}->{inbfrq} ihbfrq $self->{par}->{ihbfrq}\n");
   
    if ($hbondflag) {
      $self->{files}->{inp}->print("skipe all exclude vdw exclude elec exclude hbond exclude dihe\n");
    } else {
      $self->{files}->{inp}->print("skipe all exclude vdw exclude elec exclude dihe \n");
    }
}

sub setupMultePairNonBonded {
  my $self = shift;
  my $rn1 = uc(shift);
  my $rn2 = uc(shift);
  my $hbondflag = shift;
  $hbondflag = 0 if (!defined $hbondflag);
  my $rdie = shift;

# Gevorg's failed attempt to make multe calculate hbond 03/07/05
#  if ($hbondflag) {
#    $self->{files}->{inp}->print("update ihbfrq 1 NOACCEPTORS HBNOEXCLUSIONS ALL ctonhb $self->{par}->{ctonhb} ctofhb $self->{par}->{ctofhb} cuthb $self->{par}->{cuthb} ctonha $self->{par}->{ctonha} -\n");
#    $self->{files}->{inp}->print("      ctofha $self->{par}->{ctofha} cuthba $self->{par}->{cuthba}\n");
#  }

  if (!defined($rdie)) {
    if (($self->{par}->{_npc}->{$rn1} == 2) && ($self->{par}->{_npc}->{$rn2} == 2)) {
      $rdie = $self->{par}->{multe_pair_diel2};
    } elsif (($self->{par}->{_npc}->{$rn1} == 1) && ($self->{par}->{_npc}->{$rn2} == 1)) {
      $rdie = $self->{par}->{multe_pair_diel1};
    } else {
      $rdie = $self->{par}->{multe_pair_diel_diff};
    }
  }

#  # This update line has to be here, otherwise it crashes - ??? Gevorg
  $self->{files}->{inp}->print("update inbfrq -1 -\n");
  $self->{files}->{inp}->print("       atom rdie switch eps $rdie e14fac $self->{par}->{e14fac} cutnb $self->{par}->{cutnb} - \n");
  $self->{files}->{inp}->print("       ctofnb $self->{par}->{ctofnb} ctonnb $self->{par}->{ctonnb} nbxmod $self->{par}->{nbxmod} vswitch wmin $self->{par}->{wmin} vatom vdistance \n");
#  $self->{files}->{inp}->print("update inbfrq $self->{par}->{inbfrq} ihbfrq $self->{par}->{ihbfrq} \n");
#  $self->{files}->{inp}->print("skipe all exclude vdw exclude elec exclude dihe \n"); 

}


=head2   openCard

 Title   :  openCard 
 Usage   :  $charmm->opencard('test.tab', 12);
            12 is file descriptor for the external file test.tab
 Function:  open an external file 
 Returns :  none
 Args    :  (1) card name: file name 
            (2) unit name: it is a number to uniqly identify the file name, or card

=cut

sub openCard {
  my $self = shift;
  my $card = shift;
  my $unit = shift;
  my $mode = shift;
  $mode = "write" if (!defined($mode));
 
  $self->{files}->{inp}->print("open $mode unit $unit card name \"$card\" \n");
}


=head2   writeCard

 Title   :  writeCard
 Usage   :  $charmm->writeCard(18, '* blah.tab');
 Function:  write to external card
 Returns :  none
 Args    :  (1) card unit 
            (2) contenet to write 
               i.e. ---->  *  ?ener ?vdw ?elec ?dihe ?hbond etc.....
  Note   :  the second argument must start with "*"
=cut


sub writeCard {
    my $self=shift;
    my $unit =shift;
    my $title=shift;
   
    $self->{files}->{inp}->print("write title unit $unit\n");
    $self->{files}->{inp}->print($title);
    $self->{files}->{inp}->print("\n");
    $self->{files}->{inp}->print("*\n");
    $self->{files}->{inp}->print("\n");

}


=head2  closeCard

 Title   :  closeCard 
 Usage   :  $charmm->closeCard(18)
 Function:  close an external file 
 Returns :  none
 Args    :  charmm fortran file unit

=cut

sub closeCard {

    my $self=shift;
    my $unit=shift;
   
    $self->{files}->{inp}->print("close unit $unit \n");
}


=head2  mergeTrajectories

 Title   :  mergeTrajectories 
 Usage   :  $charmm->mergeTrajectories("all.dcd", "first.dcd", "second.dcd", ...)
 Function:  merges the specified trajectories into one
 Returns :  nothing
 Args    :  1. Output trajectory name
            2-n. Individual smaller trajectory names

=cut

sub mergeTrajectories {
  my $self = shift;
  my $outDCD = shift;
  my @inDCD = @_;

  $self->send("OPEN UNIT 20 WRITE FILE NAME \"$outDCD\"\n");
  for (my $i = 0; $i < scalar(@inDCD); $i++) {
    $self->send("OPEN UNIT " . (21 + $i) . " READ FILE NAME $inDCD[$i]\n");
  }
  $self->send("MERGE FIRSTU 21 NUNIT " . scalar(@inDCD) . " OUTPut 20 NOCHeck\n");
  for (my $i = 0; $i < scalar(@inDCD); $i++) {
    $self->send("CLOSe UNIT " . (21 + $i) . "\n");
  }
}


=head2  fixTruncatedTrajectory

 Title   :  fixTruncatedTrajectory
 Usage   :  $charmm->fixTruncatedTrajectory("truncated.dcd", N, "out.dcd")
 Function:  fixes a truncated trajectory by reading by reading from it the
            specified number of frames (this can be figured out, for example,
            via NAMD::getNumFrames("truncated.dcd")) and writing to a new
            trajectory.
 Returns :  nothing
 Args    :  1. name of truncated trajectory
            2. number of frames to read from it
            3. name of new/fixed trajectory
            4. optional: PSF file. If provided, will not need to send any
               commands to the current CHARMM object.

=cut

sub fixTruncatedTrajectory {
  my $self = shift;
  my $trDCD = shift;
  my $N = shift;
  my $outDCD = shift;
  my $psff = shift;
  my $tmpBase = CHARMM::sanitizeFilename("_fixTraj_$$." . GENERAL::GetMachine());
  my @tempFiles;

  # if PSF file not provided, make one
  if (!defined($psff)) {
    $psff = "$tmpBase.psf"; push(@tempFiles, $psff);
    $self->writePSF($psff);
    $self->wait(undef, undef, undef, 0);
  }

  # stream for looping over the old trajectory and saving into a new one
  my $strFile = "$tmpBase.stream"; push(@tempFiles, $strFile);
  my $ofh = GENERAL::GetOutFH($strFile);
  $ofh->printf("LABEL LOOP\nTRAJ READ\nTRAJ WRITE\nINCR K BY 1\nIF K LE \@N GOTO LOOP\n");
  close($ofh);

  # will need to start a new CHARMM instance, because CHHARMM
  # allocates space for a trajectory only once. So once you
  # read one, you cannot read another longer one, which we may
  # want to do in the future (who knows).
  my $cmdf = "$tmpBase.inp"; push(@tempFiles, $cmdf);
  my $chrm = CHARMM::new($self->{exec}, $cmdf);
  $chrm->send("open read unit 77 card name \"$psff\"\nread psf card unit 77\nclose unit 77\n\n");
  $chrm->send("set N = $N\nset K = 1\nOPEN READ  UNIT 21 FILE NAME \"$trDCD\"\n");
  $chrm->send("OPEN WRITE UNIT 22 FILE NAME \"$outDCD\"\n");
  $chrm->send("TRAJ FIRSTU 21 NUNIT 1 IWRITE 22 NFILE \@N\n* fixed trajectory\n*\n\n");
  $chrm->send("stream $strFile\n");
  $chrm->closeCard(21);
  $chrm->finish();

  # clean up
  foreach my $tempFile (@tempFiles) { GENERAL::crm($tempFile); }
}


=head2   setupASP

 Title   :  setupASP 
 Usage   :  $charmm->setupASP()
 Function:  sets up atomic solvation parameter based energy function
 Returns :  none
 Args    :  none 

=cut

sub setupASP {

  my $self=shift;
  $self->_getpar(@_);
  my $fhandle = $self->{files}->{inp};

  if (defined $self->{_haveasp}) {
    $fhandle->print("skip excl asp \n");
  } else {

      # here is the module to write the asp inp file 
      # first you have to write out a surface inp file: contains vdw radius
      # then you have to open this surf file

      $fhandle->print("\n", '!  Build and write out the surf file for ASP calculations',  "\n");
      $fhandle->print('open unit 1 write form name temp.surf',  "\n");
      $fhandle->print('write title unit 1',  "\n");
      $fhandle->print('** Test file for ASP calculations, all atoms w/ vdW radii and unit',  "\n");
      $fhandle->print('** solvation parameters',  "\n");
      $fhandle->print('**',  "\n");
      $fhandle->print('*  1.4  !Probe radius',  "\n");
      $fhandle->print('Calc atom = 1',  "\n");
      $fhandle->print('label donextatom',  "\n");
      $fhandle->print('   define thisone select bynu @atom end',  "\n");
      $fhandle->print('   set ResNm = ?selresn',  "\n");
      $fhandle->print('   set AtmNm = ?seltype',  "\n");
      $fhandle->print('   scalar radius stats select thisone end',  "\n");
      $fhandle->print('   set RadAtm = ?stot',  "\n\n");
      $fhandle->print('   write title unit 1',  "\n");
      $fhandle->print('* @ResNm   @AtmNm  1000.0  @RadAtm  0.0',  "\n");
      $fhandle->print('*',  "\n\n");
      $fhandle->print('   incr atom by 1',  "\n");
      $fhandle->print('if atom le ?natom goto donextatom',  "\n\n");
      $fhandle->print('close unit 1',  "\n\n");
      $fhandle->print('!  Now open this file and read it',  "\n");
      $fhandle->print('open unit 29 read form name temp.surf',  "\n");
      $fhandle->print('read surf unit 1',  "\n");
      $fhandle->print('close unit 29',  "\n\n");

      $self->{_haveasp}=1;
  }
}




=head2   clearASP

 Title   :  clearASP
 Usage   :  $charmm->clearASP()
 Function:  switch off ASP energy terms
 Returns :  none
 Args    :  none

=cut


sub clearASP {

    my $self=shift;

    if (defined $self->{_haveasp}) {
    $self->{files}->{inp}->print("skip asp \n");
    }
}


=head2   setupACE

 Title   :  setupACE 
 Usage   :  $charmm->setupACE()
 Function:  setup ACE (Analytical Continuum Electrostatics) model
 Returns :  none
 Args    :  none

=cut

sub setupACE {

    my $self=shift;
    $self->_getpar(@_);

    my $fhandle=$self->{files}->{inp};

    $fhandle->print('energy atom ace ieps 1.0 seps 80.0 alpha 1.2 sigma 3 switch -',  "\n");
    $fhandle->print('       vdis vswi cutnb $self->{par}->{cutnb} ctofnb $self->{par}->{cutoff} ctonnb $self->{par}->{cuton}',  "\n\n");

}



=head2   setupQuickDirtyMin

 Title   :  setupQuickDirtyMin 
 Usage   :  $charmm->setupQuickDirtyMin()
 Function:  setup a quick and dirty minimization charmm job
 Returns :  none
 Args    :  total steps for minimization step

=cut


sub setupQuickDirtyMin {
    
    my $self=shift;
    my $step=shift;
    $step=50 if (!defined $step);
    my $fhandle=$self->{files}->{inp};

    $fhandle->print('! quickly minimize structure',  "\n");

    $fhandle->print('MINI SD              -', "\n");
    $fhandle->print('NSTEP $step  STEP  0.05     IHBFRQ 0 INBFRQ 4 NPRINT 1 -',  "\n");
    $fhandle->print('CUTNB 8.00 WMIN 2.6 - ',  "\n");
    $fhandle->print('CTONNB 98.0 CTOFNB 99.0 CTONHB 98.0 CTOFHB 99.0',  "\n");

}



=head2  setupPeptide

 Title   :  setupPeptide
 Usage   :  $charmm->setupPeptide('A', \@seq, \@phi, \@psi, \@chi)
 Function:  Setups up a protein chain of given sequence with the ability to specify
            phi/psi angles as well as any chi angles.
 Returns :  none
 Args    :  (1) chain id 
            (2) sequence array (3-letter names)
            (3) optional: array (one shorter than sequence length) of phi angles.
                If any array element is undef, that phi angle will not be set.
            (4) optional: array (one shorter than sequence length) of psi angles.
                If any array element is undef, that psi angle will not be set.
            (5) optional: array of any additional dihedral angles. Each array
                element is a hash reference with two fields: 'def', corresponding
                to the definition of the dihedral angle (e.g. 'A 1 CA A 1 CB A 1 CG A 1 CD1')
                and 'val', corresponding to the value of the angle to set.
            (6) optional: N-terminal patch to apply (default nter)
            (7) optional: C-terminal patch to apply (default cter)
            (8) additiona options are specified via a hash:
                'seed'       -  optional: string representing the first three atoms to build, e.g. argument of 'ic seed' (by default '1 n 1 ca 1 c')
                'ori'        -  optional: flag, determining whether to run the 'coor orie' command at the end to rotate and translate the peptide. Default is yes.
                'postgopts'  -  optional: post-generation options, a CHARMM command string to be used after the generate statement

=cut


sub setupPeptide {
    my $self = shift;
    my $chain = shift;
    my $seq = shift;
    GENERAL::requireArgs($self, $chain, $seq);
    my $phi = shift;
    my $psi = shift;
    my $chi = shift;
    my $fir = shift; $fir = "nter" if (!defined($fir));
    my $las = shift; $las = "cter" if (!defined($las));
    my %opts = @_;
    my $ori = $opts{ori}; $ori = 1 if (!defined($ori));
    my $seed = $opts{seed}; $seed = "1 n 1 ca 1 c" if (!defined($seed));
    GENERAL::assert(scalar(@$phi) == scalar(@$seq)-1, "Number of phi's mismatch!") if (defined($phi));
    GENERAL::assert(scalar(@$psi) == scalar(@$seq)-1, "Number of psi's mismatch!") if (defined($psi));

    my $fhandle = $self->{files}->{inp}; 
    my $seqstr = Text::Wrap::wrap("", "", join(" ", @$seq));
    $fhandle->print("!  setup peptide\n");
    $fhandle->print("read sequ card\n");
    $fhandle->print("*  peptide\n");
    $fhandle->print("*\n");
    $fhandle->printf(" %d\n", scalar(@$seq));
    $fhandle->print("$seqstr\n\n");
    $fhandle->print("generate $chain first $fir last $las setup\n\n");
    $fhandle->send($opts{postgopts} . "\n") if (defined($opts{postgopts}));
    $fhandle->print("ic param\n");
    $fhandle->print("ic seed $seed\n");
    if (defined($phi) || defined($psi) || defined($chi)) { $fhandle->print("ic edit\n"); }
    if (defined($phi)) {
      for (my $i = 0; $i < scalar(@$phi); $i++) {
        next if (!defined($phi->[$i]));
        $fhandle->printf("dihe $chain %d C $chain %d N $chain %d CA $chain %d C $phi->[$i]\n", $i+1, $i+2, $i+2, $i+2);
      }
    }
    if (defined($psi)) {
      for (my $i = 0; $i < scalar(@$psi); $i++) {
        next if (!defined($psi->[$i]));
        $fhandle->printf("dihe $chain %d N $chain %d CA $chain %d C $chain %d N $psi->[$i]\n", $i+1, $i+1, $i+1, $i+2);
      }
    }
    if (defined($chi)) {
      for (my $i = 0; $i < scalar(@$chi); $i++) {
        $fhandle->printf("dihe $chi->[$i]->{def} $chi->[$i]->{val}\n");
      }
    }
    if (defined($phi) || defined($psi) || defined($chi)) { $fhandle->print("end\n\n"); }
    $fhandle->print("ic build\n\n");
    $fhandle->print("coor orie\n") if ($ori);
}


=head2  setupPeptide

 Title   :  setupPeptide
 Usage   :  $charmm->setupPeptide('A', 'GLU')
 Function:  setup up pentapeptide input file 
 Returns :  none
 Args    :  (1) chain id 
            (2) residue name

=cut


sub setupPeptide_old {
    
    my $self=shift;
    my $fhandle=$self->{files}->{inp}; 
    my $chain=shift;
    my $resname=shift;

    $fhandle->print('!  Set-up blocked penta-peptide',  "\n");
    $fhandle->print('read sequ card',  "\n");
    $fhandle->print('*  blocked penta-peptide',  "\n");
    $fhandle->print('*',  "\n");
    $fhandle->print(' 7',  "\n");
    $fhandle->print("Amn GLY GLY $resname GLY GLY Cbx",  "\n\n");
    $fhandle->print('generate $chain setup',  "\n\n");
    $fhandle->print('ic param',  "\n");
    $fhandle->print('ic seed 1 cl 1 c 1 o',  "\n");
    $fhandle->print('ic build',  "\n\n");
    $fhandle->print('coor orie',  "\n");

}


=head2  _getpar

 Title   :  _getpar
 Usage   :  $self->_getpar('key', 'value')
 Function:  an internal function to process the 
            input parameters for the  methods in 
            charmm object.
 Returns :  set up correct $self->{par} data
 Args    :  key value pairs

=cut

sub _getpar {
  my $self = shift;
  my %arg = @_;
  foreach my $n ( keys %arg ) {
    if (exists $self->{par}->{$n}) {
      $self->{par}->{$n}=$arg{$n};
    }
  }
}




=head2   setupGB

 Title   :  setupGB
 Usage   :  $charmm->setupGB()
 Function:  sets up the Generalized Born solvent approximation 
            The non-bonded interactions are set to constant 
            dielectric, epsilon = 1.0, and force switching. GB 
            is then initialized and will be used in all
            subsequent energy evaluations. 
 Returns :  none
 Args    :  none

=cut


sub setupGB {

    my $self=shift;
    $self->_getpar(@_);

    my $fhandle=$self->{files}->{inp};
    $fhandle->print("update CDIE eps 1.0 cutnb $self->{par}->{cutnb} ctofnb $self->{par}->{cutoff} ctonnb $self->{par}->{cuton} switch vswitch\n\n");

    $self->_setupOrigGB();
    
}


### setup original GB ######

sub _setupOrigGB {
    
    my $self=shift;
    $self->_getpar(@_);
    my $fhandle=$self->{files}->{inp};
    
    $fhandle->print("scalar wmain = radius \n");
    my $lambda;
    if ($self->{par}->{param} == 19) {
    $fhandle->print("scalar wmain mult $self->{par}->{gbcrad} select type c end \n");
    $lambda=(defined $self->{par}->{gblambda})?$self->{par}->{gblambda}:0.7295;
    $fhandle->print("gborn p1 0.4152 p2 0.2386 p3 1.7558 p4 10.5082 p5 1.1 lambda $lambda Epsilon $self->{par}->{gbeps} weight\n");
    } elsif ($self->{par}->{param} == 22) {
    $fhandle->print("scalar wmain set $self->{par}->{gbhrad} select ( prop radius .lt. 0.8 )  end \n");
    $lambda=(defined $self->{par}->{gblambda})?$self->{par}->{gblambda}:0.705;
    $fhandle->print("gborn p1 0.448 p2 0.173 p3 0.013 p4 9.015 p5 0.9 lambda $lambda Epsilon $self->{par}->{gbeps} weight \n");
    }
}


=head2   clearGB

 Title   :  clearGB
 Usage   :  $charmmobj->clearGB()
 Function:  clear and switch off Generalized Born solvent
            approximation 
 Returns :  none
 Args    :  none

=cut

sub clearGB {
    my $self=shift;
    $self->{files}->{inp}->print("gborn clear\n");
}


=head2   minimizeSD

 Title   :  minimizeSD 
 Usage   :  $charmm->minimizeSD()
 Function:  runs a steepest descent minimization.
            Parameters are the non-bonded list update 
            frequency, updnbsd, the number of minimization 
            steps, itersd, and the initial step size stepsd.
 Example :  You want to run a minimization on a protein

 Returns :  none
 Args    :  key/value pair

=cut

sub minimizeSD { 
    my $self=shift;
    $self->_getpar(@_);
    $self->{files}->{inp}->print("mini sd inbfreq $self->{par}->{updnbsd} step $self->{par}->{stepsd} nstep $self->{par}->{itersd} \n");
}


=head2   minimizeABNR

 Title   :  minimizeABNR()  
 Usage   :  $charmm->minimizeABNR()
 Function:  runs adopted-basis Newton-Raphson 
            minimization. Parameters are the 
            non-bonded list update frequency: updnbabnr
            the number of minimization steps: iterabnr,
            the initial step size: stepabnr and an energy 
            tolerance: etolabnr to limit the minimization 
            run if the tolerance is reached in less than 
            the requested number of runs.
 Example :  A quick and dirty ABNR optimizer

 Returns :  none
 Args    :  key/value pair

=cut

sub minimizeABNR {
    my $self=shift;
    $self->_getpar(@_);
    $self->{files}->{inp}->print("mini abnr inbfreq $self->{par}->{updnbabnr} step $self->{par}->{stepabnr} nstep $self->{par}->{iterabnr} tolenr $self->{par}->{etolabnr}\n");
}


=head2   minimizeConjGrad

 Title   :  minimizeConjGrad
 Usage   :  $charmm->minimizeConjGrad
 Function:  runs conjugate gradient minimization Parameters 
            are the non-bonded list update frequency: updnbconj,
            the number of minimization steps: iterconj, the 
            initial step size: stepconj and an energy tolerance:
            etolconj.
 Example :  
 Returns :  none
 Args    :  none

=cut


sub minimizeConjGrad {
    my $self=shift;
    $self->_getpar(@_);
    $self->{files}->{inp}->print("mini conj inbfreq $self->{par}->{updnbconj} step $self->{par}->{stepconj} nstep $self->{par}->{iterconj} tolenr $self->{par}->{etolconj}\n");
}


=head2   simpleRestraint

 Title   :  simpleRestraint
 Usage   :  $charmm->simpleRestraint()
 Function:  requests harmonic restraints with a simpler
            interface: harmonicRestraint. The arguments are a
            force constant, a CHARMM selection expression and
            flags whether to keep previous coordinates and whether
            to use coordinates from the alternate coordinate set
 Returns :  none
 Args    :  none

=cut

sub simpleRestraint {
    my $self=shift;
    my $force=shift;
    my $select=shift;
    my $keep=shift;
    my $comp=shift;

    my $compstr=(defined $comp && $comp)?"COMP":"";
    my $keepstr=(defined $keep && $keep)?"KEEP":"";
  
    my $cmd="cons harm force $force mass select $select end $compstr $keepstr\n";
    $self->{files}->{inp}->print($cmd);
}  


=head2  writePDB

 Title   :  writePDB(file)
 Usage   :  $charmm->writePDB(file)
 Function:  Make CHARMM write out the current coordinates to a file
            in PDB format.
 Returns :  none
 Args    :  pdb file name

=cut


sub writePDB {

  my $self = shift;
  my $pdbfile = shift;
  my $selection = shift;
  my $title = shift;
  $selection = " " if (!defined($selection));
  $title = "* PDB\n*" if (!defined($title));
  my $fhandle = $self->{files}->{inp};

  $fhandle->print("\n!write into external pdb file.\n");
  $fhandle->print("open unit 88 write form name \"$pdbfile\"\n");
  $fhandle->print("write coor pdb $selection unit 88\n$title\n");
  $fhandle->print("close unit 88 \n");
}


=head2  writePSF

 Title   :  writePSF(file)
 Usage   :  $charmm->writePSF(file)
 Function:  Make CHARMM write out the current PSF into a text file.
 Returns :  none
 Args    :  psf file name

=cut


sub writePSF {

  my $self = shift;
  my $psffile = shift;
  my $xplor = shift;
  $xplor = "" if (!defined($xplor));
  my $title = shift;
  $title = "* PSF\n*" if (!defined($title));
  my $fhandle = $self->{files}->{inp};

  $fhandle->print("\n!write into external psf file\n");
  $fhandle->print("open write unit 88 card name \"$psffile\"\n");
  $fhandle->print("write psf card $xplor unit 88\n$title\n");
  $fhandle->print("close unit 88 \n");
}


=head2  writeCRD

 Title   :  writeCRD
 Usage   :  $charmm->writeCRD(file_name)
 Function:  Make CHARMM write out the current coordinates to a file in CRD format
 Example :  $charmm->writeCRD("test.crd", "select group end")
            it will only write the defined group selection
 Returns :  none
 Args    :  (1) file name you want to write out
            (2) the part you want to write out

=cut


sub writeCRD {
    
  my $self = shift;
  my $crdfile = shift;
  my $selection = shift;
  my $title = shift;
  $selection=" " if (!defined $selection);
  $title = "* CRD\n*" if (!defined($title));

  my $fhandle = $self->{files}->{inp};

  $fhandle->print("\n!write into external crd file.\n");
  $fhandle->print("open write unit 77 card name \"$crdfile\"\n");
  $fhandle->print("write coor card $selection unit 77\n$title\n");
#  $fhandle->print("close unit 77 \n"); # - no need to close since CHARMM closes automatically, I think.
}




=head2   orient

 Title   :  orient()
 Usage   :  $charmm->orient()
 Function:  orients the current structure centered at the origin
            and with the principal moments of inertia aligned with
            the principal axes.
 Returns :  none
 Args    :  none

=cut

sub orient {

  my $self=shift;
  $self->{files}->{inp}->print("coor orie\n");

}

=head2   getScalar

 Title   :  getScalar
 Usage   :  getScalar()
 Function:  obtains the list of values for a scalar
            quantity in CHARMM.
 Returns :  none
 Args    :  the name of scalar variable needed to be print out

=cut

sub getScalar {

  my $self=shift;
  my $name=shift;
  $self->{files}->{inp}->print("scalar $name show \n");

}


=head2   solvAccessSurf

 Title   :  solvAccessSurf([accu[,rprobe]])
 Usage   :  $charmm->solvAccessSurf 
 Function:  calculates the solvent accessible surface area.
            A desired accuracy and probe radius may be
            given as argument.
 Returns : 
 Args    : 

=cut

sub solvAccessSurf {

  my $self=shift;
  my $accu=shift;
  my $rprobe=shift;
  
  $accu=0.005 if (!defined $accu);
  $rprobe=1.4 if (!defined $rprobe);

  $self->{files}->{inp}->print("coor surface accu $accu rprobe $rprobe \n");

}  


=head2   getEnergy

 Title   :  getEnergy()
 Usage   :  $charmm->getEnergy()
 Function:  evaluates the energy of the current conformation
            and returns a data structure with the energy components
 Returns : 
 Args    : 

=cut

sub getEnergy {
  my $self=shift;
  $self->{files}->{inp}->print("energy\n");
}



=head2   defineTemplate

 Title   : defineTemplate
 Usage   : $charmmobj->defineTemplate($rotamer)
           $charmmobj->defineTemplate(\@residues)
 Function: Defines the backbone (backb) and the template (template) as CHARMM
           selections. Template = backbone + non-design sites. The backbone
           can either contain waters (if any) or not.
 Returns : Nothing
 Args    : 1. CHARMM object
           2. Rotamer object reference or a reference to an array of residues,
              which designate the design sites
           3. Optional: string flag, which specifies whether the template is to be
              constrained. "yes" means constrain, anything else means do not. "yes"
              is the default.
           4. Optional: logical flag, which specifies whether water is to be included
              in the backbone selection. Default is set by CHARMM::backbone($water).

=cut

sub defineTemplate {
  my $self = shift;
  my $dsites = shift;
  GENERAL::requireArgs($self, $dsites);
  my $cons = shift;
  $cons = "YES"  if (!defined $cons);
  my $water = shift;

  my $fhandle = $self->{files}->{inp};
  # define protein backbone atoms: 
  $fhandle->print("define backb select " . CHARMM::backbone($water) . " end\n");

  # define the template: everything except the side chains of interested sites
  $fhandle->print("define des_sites select none end\n");
  if (ref($dsites) eq "ROTAMER") {
    foreach my $site (@{$dsites->{dslist}})  {
      $fhandle->print("define des_sites select des_sites .or. .byres. atom $site->{chain} $site->{iresnum} n end\n");
    }
  } else {
    foreach my $site (@$dsites)  {
      $fhandle->print("define des_sites select des_sites .or. .byres. atom $site->{chain}->{id} $site->{iresnum} n end\n");
    }
  }

  # define the template: everything except the side chains of interested sites
  $fhandle->print("define template select backb .or. .not. des_sites end\n");

  # define the designed sites: everything except the template
  $fhandle->print(qq(define rots select .not. template end \n));

  # choose to fix the template and delete the side chains at design sites
  $fhandle->print("cons fix sele template end\n") if ( uc($cons) eq 'YES');
}


=head2   deleteDesignSite

 Title   :  deleteDesignSite
 Usage   :  $charmmobj->deleteDesignSite()
 Function:  
 Returns :
 Args    :  

=cut


sub deleteDesignSite {
  my $self = shift;
  my $fhandle = $self->{files}->{inp};
  $fhandle->print("dele atom select rots end \n");
}


=head2    defineUnfoldTemplate

  Title   :  defineUnfoldTemplate
  Usage   :  $charmmobj->defineUnfoldTemplate($chainid)
  Function:  Define the template in unfold calculations, delete 
             the side chain 
  Returns : 
  Args    :  (1) chain id
             (2) residue name
=cut



sub defineUnfoldTemplate {
  my $self = shift;
  my $segid = shift;
  my $resnum = shift;
  GENERAL::requireArgs($self, $segid, $resnum);
  my $cons = shift;
  $cons = "yes" if (!defined($cons));
  
  my $fhandle = $self->{files}->{inp};
  
  # define the backbone selection
  #    (1) N,CA,O,C   ----> mainchain atoms
  #    (2) H attach to N
  
  $fhandle->print("define backb select type N .or. type CA - \n");
  $fhandle->print("    .or. type C .or. type O .or. type H - \n");
  $fhandle->print("    .or. type CY .or. type OY .or. type CAY end\n\n");
  
  # define the template: every except side chains of design sites
  # we select by using residue name. Reason: 
  # in case it is terminal or near terminal residue. We don't have peptapeptide
  
  $fhandle->print("define template select backb .or. .not. - \n");
  $fhandle->print("      resid $resnum end\n\n");
  
  # define designed side chains: everything except template
  $fhandle->print("define rots select .not. template end\n\n");
  
  # fix the template
  $fhandle->print("cons fix sele template end\n") if ($cons eq "yes");
  
}


=head2    defineGroup

 Title   :  defineGroup
 Usage   :  defineGroup($chain, $irsenum);
 Function:
 Returns :
 Args    :

=cut


sub defineGroup {
  my $self=shift;
  my $fhandle=$self->{files}->{inp};
  my $chain=shift;
  my $iresnum=shift;
  $fhandle->print("define group select .byres. atom $chain $iresnum N - \n");
  $fhandle->print("  .and.  .not. backb end \n\n");
  $fhandle->print("ic param \n\n");
}


=head2   defineResidue

 Title   :  defineResidue
 Usage   :  defineRsidue($chain, $irsenum);
 Function:
 Returns :
 Args    :

=cut


sub defineResidue {

     my $self=shift;
     my $fhandle=$self->{files}->{inp};
     my $chain=shift;
     my $iresnum=shift;
     $fhandle->print("define bigres select .byres. atom $chain $iresnum N end \n\n");
     
}



=head2    patchResidue

 Title   : patchResidue
 Usage   : $charmm->patchResidue("ARG", "B", "14")
 Function: Tells CHARMM to delete the side-chain at a given site and patch with the given residue.
           In the case when proline is being patched, the amide hydrogen is also removed (if it exists)
 Returns : nothing 
 Args    : 0. CHARMM structure
           1. Residue name
           2. Chain name
           3. Residue number
=cut

sub patchRes {
  my $self = shift;
  my $resname = uc(shift);
  my $chain = shift;
  my $iresnum = shift;
  GENERAL::requireArgs($self, $resname, $chain, $iresnum);
  my $fh = $self->{files}->{inp};

  # Delete the previous residue
  $fh->print("delete atom select .byres. atom $chain $iresnum * .and. .not. (" . CHARMM::backbone() . ") end \n");
#  $fh->print("delete atom select rots end\n");

  # If we are patching proline, delete the amide hydrogen
  if ($resname =~ /PRO/) {
    $fh->print("define ggg_one select atom $chain $iresnum H end\n");
    $fh->print("IF ?nsel .NE. 0 THEN DELEte atom select atom $chain $iresnum H end\n");
  }

  # Patch residue
#  if ($resname =~ /GLY/) { # for GLY, nothing needs to be done
#  }
  if (($resname =~ /PRO/) && ($iresnum == 1)) {
    # If N-terminal proline, use the patch that is missing the improper dihedral to enforce
    # planarity of (-C CA *N CD) since -C does not exist. Two dihedrals are needed to defined
    # the location of CD in this case.
    $fh->print("patch PPRT $chain $iresnum setup\n");
    $fh->print("autogenerate angles\n\n");
  } else {
    $fh->print("patch P$resname $chain $iresnum setup\n");
    $fh->print("autogenerate angles\n\n");
  }

  # If we are patching on top of PRO with a non-PRO, make sure an H is added
  if ($resname !~ /PRO/) {
    $fh->print("define ggg_one select atom $chain $iresnum * end\n");
    $fh->print("if ?SELRESN .EQ. PRO THEN patch PAMD $chain $iresnum\n");
    $fh->print("if ?SELRESN .EQ. PRO THEN hbuild\n");
  }

  # Rename the residue
  $fh->print("rename RESN $resname select atom $chain $iresnum * end\n");
}


=head2  placeRotamer

 Title   :  placeRotamer
 Usage   :  $charmm->placeRotamer($chain, $resname, $iresnum, $chidef, $rot)
 Function:  Places the specified rotamer onto the specified site of the current
            structure.
 Returns :  nothing
 Args    :  0. CHARMM structure
            1. chain id
            2. residue name
            3. residue serial number
            4. chi definitions structure
            5. reference to the rotamer
=cut

sub placeRotamer {
  my $self = shift;
  my $chain = shift;
  my $resname = shift;
  my $iresnum = shift;
  my $chidef = shift;
  my $rot = shift;

  GENERAL::requireArgs($self, $chain, $resname, $iresnum, $chidef, $rot);

  # Rebuild rotamer
  my $fhandle = $self->{files}->{inp};
  $fhandle->print("coor init select .byres. atom $chain $iresnum * .and. .not. (" . CHARMM::backbone() . ") end \n");
  if (uc($resname) =~ /GLY/) {
  } elsif (uc($resname) =~ /ALA/) {
    $fhandle->print("ic param \n\n");
    $fhandle->print("ic build \n\n");
  } else {
    $fhandle->print("ic param \n");
    $fhandle->print("ic edit \n\n");
    my $j = 0;
    my $site = "$chain $iresnum";
    my $angleref = $rot->{chi};
    # specify the dihedral angles to be rebuilt
    foreach my $i (@{$chidef->{$resname}}) {
      GENERAL::error("dihe $site $i->[0] $site $i->[1] $site $i->[2] $site $i->[3]. Chi angle number " . ($j+1) .
                     " was not found.") if (!defined $angleref->[$j]);
      $fhandle->print("dihe $site $i->[0] $site $i->[1] $site $i->[2] $site $i->[3] $angleref->[$j] \n");
      $j++;
    }
    $fhandle->print("end\n");
    $fhandle->print("ic build\n\n");
  }

# OLD VERSION
#   my $self = shift;
#   my $fhandle = $self->{files}->{inp};
# 
#   # here angleref is the reference to each line in rotamer library
# 
#   my $chidef = shift;
#   my $angleref = shift;
#   my $resname = shift;
#   my $chain = shift;
#   my $iresnum = shift;
#   GENERAL::requireArgs($self, $chidef, $angleref, $resname, $chain, $iresnum);
#   my $manystr = shift;
#   my $manyflag;
#   $manyflag = 0 if (!defined $manystr);
#   $manyflag = 1 if (defined $manystr);
# 
#   my $site= $chain." ".$iresnum;
# 
# 
#   # select the site need to be rebuilt
#   if ( $manyflag==0) {
#     $fhandle->print("coor init select rots end \n");
#   }
#   if ( uc($resname) eq "ALA" ) {
#     if ( $manyflag==0) {
#      $fhandle->print("ic param \n");
#      $fhandle->print("ic build \n\n");
#     }
#   } else {
#     if ( $manyflag==0) {
#          $fhandle->print("ic param \n");
#          $fhandle->print("ic edit \n\n");
#     }
# 
#     my $j=0;
# 
#     # specify the dihedral angles to be rebuilt
#     foreach my $i (@{$chidef->{$resname}}) {
#       print "dihe $site $i->[0] $site $i->[1] $site $i->[2] $site $i->[3]  No value defined for angle (chi " . ($j+1) . ").\n" if (!defined $angleref->[$j]);
#      #     if (defined $angleref->[$j] ) {
#       $fhandle->print("dihe $site $i->[0] $site $i->[1] $site $i->[2] $site $i->[3] $angleref->[$j] \n");
#     #     }
#       $j++;
#     }
# 
#     if ( $manyflag==0) {
#       $fhandle->print("end\n\n");
#       $fhandle->print("ic build\n\n");
#     }
#   }

}


=head2   renameRes

 Title   :  renameRes
 Usage   :  $charmmobject->rename("A", 'ARG') 
 Function:  For a given pentapeptide, change the name of residue 3 at 
            chain A into name 'ARG'
 Example :  The problem: in modeling unfolding state, one need to put 
            All 18 amino acids (except PRO and GLY) on to site 3 at 
            pentapeptide. One needs charmm to do it.

 Returns : 
 Args    :  (1) chain ID
            (2) residue name
=cut

sub renameRes {

    my $self=shift;
    my $fhandle=$self->{files}->{inp};
    my $segid=shift;
    my $resname=shift;
    my $iresnum=shift; 
    $iresnum=3 if (!defined $iresnum);

    $fhandle->print('prnlev 0',  "\n");
    $fhandle->print("rename resname $resname select segid $segid  .and. resid 3 end   \n\n");
    $fhandle->print('prnlev 5',  "\n\n");

}


=head2  writeMulteCRD

 Title   :  writeMulteCRD
 Usage   : 
 Function:  write out dummy crd file for multe calculations
 Returns : 
 Args    :  (1) unit name   (2) selection 

=cut


sub writeMulteCRD {
  my $self = shift;
  my $fhandle = $self->{files}->{inp};
  my $unit = shift;
  my $selection = shift;
  my $title = shift;
  $selection = " " if (!defined($selection));
  $title = "* MulteCRD\n*" if (!defined($title));

#    $selection ='sele rots end' if (!defined $selection);
  if (!defined $selection) { $selection = " "; }
  if (!defined $unit) { GENERAL::error("please assign unit name for the crd file you want to write out."); }
  $fhandle->print("write coor dumb $selection unit $unit\n$title\n");
}




=head2 

 Title   :  assignCharge 
 Usage   : 
 Function:  assign charge to current coordinate set when write out the coordinate file
 Returns : 
 Args    : 

=cut

sub assignCharge {
    my $self=shift;
    my $fhandle=$self->{files}->{inp};
    $fhandle->print("scalar wmain = charge \n");
}




=head2 

 Title   :   selectINTE
 Usage   : 
 Function:   select the interaction energy we want to get
 Returns : 
 Args    : 

=cut

sub selectINTE {

    my $self=shift;
    my $fhandle=$self->{files}->{inp};
    my $selection1=shift;
    my $selection2=shift;
    my $keep=shift;
    $selection1='sele group end' if (!defined $selection1); 
    $selection2='sele group .or. template end' if (!defined $selection2);
    if (defined $keep) {
           $keep='keep';
    } else {
           $keep=" ";
    }

    $fhandle->print("inte $keep $selection1 $selection2 \n\n");
}

=head2 

 Title   : inte
 Usage   : $charmm->inte("sele .. end", "sele .. end", 18, "vdw elec", "dihe");
 Function: Tells the CHARMM script to calculate the interaction energy between the two
           specified selections and optionally write some of the terms to the specified
           unit number. Specificly tells the script to write zeros if any of the selections
           are empty at run time (otherwise, the previous value of the terms are written -
           very bad).
 Returns : Nothing
 Args    : 1. CHARMM data structure.
           2. Selection one
           3. Selection two
           4. Optional: unit number to write terms to
           5. Optional: an array of terms to write. Each entry of the array can be a string of
              one or more terms to write on one line.

=cut

sub inte {
  my $self = shift;
  my $sele1 = shift;
  my $sele2 = shift;
  GENERAL::requireArgs($self, $sele1, $sele2);
  my $unit = shift;
  my @terms = @_;
  if (defined($unit) && (scalar(@terms) == 0)) {
    GENERAL::error("Unit specified, but no terms to write");
  }

  # If one selection is empty, it is supposed to the same as the other
  if ($sele2 =~ /^\s*$/) { $sele2 = $sele1; }
  elsif ($sele1 =~ /^\s*$/) { $sele1 = $sele2; }

  my $fh = $self->{files}->{inp};
  $fh->print("set f 1\n");
  $fh->print("define ggg_one $sele1\n");
  $fh->print("IF ?nsel .EQ. 0 THEN set f 0\n");
  $fh->print("define ggg_two $sele2\n");
  $fh->print("IF ?nsel .EQ. 0 THEN set f 0\n");
  $fh->print("IF \@f .EQ. 1 THEN inte sele ggg_one end sele ggg_two end\n");
  if (defined($unit)) {
    foreach my $tarr (@terms) {
      my @tarr = split(" ", $tarr);
      foreach my $term (@tarr) {
        $fh->print("IF \@f .EQ. 1 THEN set value$term \?$term\n");
        $fh->print("IF \@f .EQ. 0 THEN set value$term 0\n");
      }
    }
    $fh->print("write title unit $unit\n");
    foreach my $tarr (@terms) {
      my @tarr = split(" ", $tarr);
      $fh->print("* \@value" . join(" \@value", @tarr) . "\n");
    }
    $fh->print("*\n\n");
  }
}


=head2

 Title   :   setupMultePair
 Usage   :
 Function:   set up inp line for multe calculations
 Returns :
 Args    :

=cut

sub setupMultePair {
  my $self = shift;
  my $s1 = shift;
  my $res1 = shift;
  my $s2 = shift;
  my $res2 = shift;
  my $pairtab = shift;
  my @terms = @_;
  GENERAL::requireArgs($self, $s1, $res1, $s2, $res2, $pairtab, \@terms);
  
  my $fhandle = $self->{files}->{inp};
  my $inp1 = $FS_DEF->{rot_outf}; $inp1 =~ s/%%/$s1/; $inp1 =~ s/%/$res1/;
  my $inp2 = $FS_DEF->{rot_outf}; $inp2 =~ s/%%/$s2/; $inp2 =~ s/%/$res2/;
  
  # Find out how many atoms in the first residue
  my $tmp = `head -n 1 $inp1`; chomp($tmp);
  my @tmp = split(" ", $tmp);
  my $num = $tmp[0]+1;
  
  $fhandle->print("\nmlte atni 1 atnj $num fili \"$inp1\" - \n");
  $fhandle->print("      filj \"$inp2\" outf \"$pairtab\" - \n");
  if (scalar(@terms) > 0) { $fhandle->print("      eter " . join(" eter ", @terms) . "\n"); }
    
#    if ($hbondflag) {
#          $fhandle->print("      eter vdw eter elec eter hbon\n\n");
#    } else {
#          $fhandle->print("      eter vdw eter elec \n\n");
#    }
}




=head2 

 Title   : writeRotamerCRD 
 Usage   : 
 Function: 
 Returns : 
 Args    : (1) file name: i.e.   rot/blah.crd
           (2) unit name for write inp for multe
           (3) unit name for write inp for eef
           (4) index of rotamer

=cut

sub writeRotamerCRD {

    my $self=shift;
    my $fname1=shift;
    my $fname2=shift;
    my $unit1=shift;
    my $unit2=shift;
    my $k=shift;

    # for every residue, write out .crd for first rotamer
    if ($k==0) {
      $self->assignCharge();
      $self->writeCRD($fname1, 'sele group end');
    }
    # note: this write to previous openned united
    $self->writeMulteCRD($unit1);

    if ($k==0) {
      $self->assignCharge();
      $self->writeCRD($fname2, 'sele bigres end');
    }

    $self->writeEEFCRD($unit2);
}




=head2 

 Title   : writeEEFCRD 
 Usage   : 
 Function: 
 Returns : 
 Args    : 
           unit name for write inp for eef
=cut


sub writeEEFCRD {
  my $self = shift;
  my $fhandle = $self->{files}->{inp};
  my $unit = shift;
  my $title = shift;
  $title = "* EEFCRD\n*" if (!defined($title));

  $fhandle->print("write coor dumb sele bigres end unit $unit\n$title\n\n");
}



=head2 

 Title   : setupWater 
 Usage   : 
 Function: 
 Returns : 
 Args    : 

=cut

sub setupWater {
    
    my $self=shift;
    my $crdfile=shift;

    # get the number of tip3 water molecules.
    my $crd=&GENERAL::GetInFH($crdfile);
    my @crd=<$crd>;
    my @solv = grep { /SOLV/ } @crd;
    my $watnum=$#solv + 1;

    my $fhandle=$self->{files}->{inp};
    $fhandle->print("read sequ tip3 $watnum\n*\n");
    $fhandle->print("generate SOLV setup noangle\n\n");
}


=head2 

 Title   :  calculateTotal
 Usage   : 
 Function:  calculate the sum of eef1, vwd, elec, dihedral energy
 Returns : 
 Args    : 

=cut

sub calculateTotal {

    my $self=shift;
    my $fhandle=$self->{files}->{inp};
    my $haveterm=$_[0];
    my @term;

    if (!defined $haveterm) {
    @term=('asp', 'vdw', 'elec','dihe');
    } else {
    @term=@_;
    }

    my $total='Calc total = ';

    my $k=0;
    foreach my $j (@term) {
    my $line="Calc $j = \?$j \n";
    $fhandle->print($line);
    $total .= "\?$j \+ "   if ( $k < $#term );
    $total .= "\?$j \n\n"     if ( $k == $#term);
        $k++;
    }
                  
    $fhandle->print($total);

}


=head2

 Title   : setCrystalCRD
 Usage   : $charmm->setCrystalCRD
 Function:
 Returns :
 Args    :

=cut

sub setCrystalCRD {
   
   my $self=shift;
   my $fhandle=$self->{files}->{inp};
 
   my $s=shift;
   my $c=shift;

   my $crd='../crd/rot-'.$c.'-'.$s.'.crd';   
   my $crdfh=&GENERAL::GetInFH($crd);
   $fhandle->print("\n\n");

   $fhandle->print("read coor card resid unit 5\n");
   while (<$crdfh>) {
        $fhandle->print($_);
   }

   $fhandle->print("\n");
}



=head2

 Title   : setRotCoord
 Usage   : $charmm->setRotCoord($chain, $iresnum, $rotpdb)
 Function: sets the coordinates of the given side chain according
           to the given rotamer PDB (a reference to residue with
           the appropriate coordinates).
 Returns : nothing.
 Args    : 1. the name of the chain the side chain belongs to
           2. the serial number of the site on the chain
           3. reference to residue with the appropriate coordinates

=cut

sub setRotCoord {
  my $self = shift;
  my $chain = shift;
  my $iresnum = shift;
  my $rot = shift;
  GENERAL::requireArgs($self, $chain, $iresnum, $rot);

  my $fhandle = $self->{files}->{inp};
  my @sc = PDB::sidechain($rot);
  return if (scalar(@sc) == 0);
  $fhandle->print("read coor card resid unit 5\n*\n");
#  $fhandle->print(scalar(@{$rot->{atom}}) . "\n");
  $fhandle->print(scalar(@sc) . "\n");
  my $i=0;
#  foreach my $atom (@{$rot->{atom}}) {
  foreach my $atom (@sc) {
    $fhandle->printf("%5d%5d %-4s %-4s%10.5f%10.5f%10.5f %-4s %-4d%10.5f\n", $i,
            $iresnum, $rot->{resname}, $atom->{atomname}, $atom->{xcoor}, $atom->{ycoor},
            $atom->{zcoor}, $chain, $iresnum, 0.0);
    $i++;
  }
}



=head2 

 Title   : setCRD 
 Usage   : $charmm->setCRD
 Function: 
 Returns : 
 Args    : 

=cut


sub setCRD {

  my $self=shift;
  my $fhandle=$self->{files}->{inp};

  my $s=shift;
  my $res=shift;
  my $rot=shift;
  my $chain=shift;

  $fhandle->print("read coor card resid unit 5 \n");
  my $crd = $FS_DEF->{rot_crdf};
  $crd =~ s/%%/$s/; $crd =~ s/%/$res/;
  $crd = File::Spec->abs2rel($crd);
  my $coord = $FS_DEF->{rot_outf};
  $coord =~ s/%%/$s/; $coord =~ s/%/$res/;
  $coord = File::Spec->abs2rel($coord);

  my $crdfh=&GENERAL::GetInFH($crd);
  my $coordfh=&GENERAL::GetInFH($coord);

  my $atomno;
  my $start=999;
  my $end=999;
  my @coor;

  # now read in dumb formatted coordinate file
  my $line=0;
  while (<$coordfh>) {
    # find out what is the atom number for each rotamer side chain
    $line++;
    if ( $line==1) {
        my @lines=split(" ", $_);
        $atomno=$lines[0];
        $start=$atomno*$rot+2;
        $end=$atomno*($rot+1)+1;
    }

    # collect the coords
    if ( $line >= $start && $line <= $end) {
              chomp ($_);
        push (@coor, $_);
    }

  }
  close $coordfh;

  # write out new coord in charmm script
  my $atomindex=-1;
  my $i=0;
  while (<$crdfh>) {
    $i++;
    if ($i <=4) {
      $fhandle->print($_);
      next;
    } elsif ($i >4)  {
      $atomindex++;
      my @xyz=split(" ", $coor[$atomindex]);
      my @lines=split(" ", $_);
      my $bigstr=sprintf("%5d%5d %-4s %-4s%10.5f%10.5f%10.5f %-4s %-4d%10.5f\n",$lines[0],
              1, $lines[2], $lines[3],$xyz[0], $xyz[1],$xyz[2], $chain, 1, 0.0);
      $fhandle->print($bigstr);
    }
  }
  close $crdfh;
}


sub  setupFromCRDWithVitualAtom  {

    my $self=shift;
    my $crdfile=shift;
    my $fhandle=$self->{files}->{inp}; 
    
    my $crd=PDB::new($crdfile);
    $self->{_crd}=$crd;
  
    my $clist=$crd->{pickedchains};
    my $terminal="none";
    
    for (my $i=0; $i<=$#{$clist}; $i++) {
    my $first="";
    my $last="";
    my $c=$clist->[$i];

    if ($terminal eq "none") {
        $first="firs none";
        $last="last none";
    } elsif ( uc($terminal) =~ /TER/) {
        $first="firs nter";
        $last="last cter";
    }

    # here we setup the squence reading

    $fhandle->print("!now read in the sequence information\n\n");

    if ($c->{id} =~ /SOL/ ) { 
        my $num= $#{$c->{res}}+1;
        $fhandle->print("read sequence TIP3 $num\n*\n");
        $fhandle->print("generate SOLV noangle nodihedral \n\n");
    }  else { 
        $fhandle->print("read sequence card\n*\n");
        
        # now prepare the squence list, loop over the residue list
        my @seq;
        # calculate total residue number in that chain
        my $resnum=$#{$c->{res}}+1;
        
        foreach my $r (@{$c->{res}}) {
        push (@seq, $r->{resname});
        }
        
        $fhandle->print("$resnum\n");
        my $k=0;
        for (my $i=0; $i<=$#seq; $i++) {
        $fhandle->print("$seq[$i] ");
        $k++;
        # every line inlcudes 15 residues
        if ($k == 15) {
            $fhandle->print("\n");
            $k=0;
        }
        }
        $fhandle->print("\n");
        $fhandle->print("generate $c->{id} $first $last setup warn \n\n");
        }
    }
 
    # here we set up virtual atoms
    
    $fhandle->print(  "\n");
    $fhandle->print('!read virtual atoms to hold Crick parameters',  "\n");
    $fhandle->print('read sequence card unit 5',  "\n*\n");
    $fhandle->print("1 VIR \n");
    $fhandle->print('generate c firs none last none',  "\n");
    $fhandle->print('generate d duplicate c',  "\n");
    $fhandle->print('generate e duplicate c',  "\n");
    $fhandle->print('generate f duplicate c',  "\n");
    $fhandle->print(  "\n");
    $fhandle->print('bomlev -1',  "\n");
    $fhandle->print(  "\n");
    
    # now read in coordinate
    $fhandle->print("open read unit 10 card name \"$crdfile\"  \n");    
    $fhandle->print("read coor card resid unit 10  \n");
    $fhandle->print("close unit 10  \n\n");

    $fhandle->print(  "\n");
    $fhandle->print('hbuild',  "\n");
    $fhandle->print('print coor',  "\n");
    $fhandle->print(  "\n");
}


sub writeOptCrick {

    my $self=shift;
    my $omega=shift;
    my $zoffset=shift;
    my $fhandle=$self->{files}->{inp};

    $fhandle->print(  "\n");
    $fhandle->print('!fix alpha helical parameters here',  "\n");
    $fhandle->print('!fix the x coordinate of segid d to 15.2 = 10x alpha helix pitch',  "\n");
    $fhandle->print("scal x set $omega sele segid d end \n");
    $fhandle->print('!fix the z coordinate of segid d to -2.26 = alpha helix radius,',  "\n");
    $fhandle->print('! negative because it is relative to origin of superhelix, which lies at +R0 on x axis',  "\n");
    $fhandle->print("scal z set $zoffset sele segid d end \n");
    $fhandle->print(  "\n");
    $fhandle->print('!use only the user energy since we will only change Crick parameters',  "\n");
    $fhandle->print('! means "skip all except user energy"',  "\n");
    $fhandle->print('skip all excl user',  "\n");
    $fhandle->print(  "\n");
    $fhandle->print('!fix everything except OMEGA, Zoffset',  "\n");
    $fhandle->print('!this is necessary to get convergence from BAD starting geometries',  "\n");
    $fhandle->print('cons fix sele .not. (segid c) end',  "\n");
    $fhandle->print(  "\n");
    $fhandle->print('!optimize Crick parameters by minimizing under constraints',  "\n");
    $fhandle->print(' mini sd nstep 200 step 0.10 nprint 10 ihbfrq 25 inbfrq 25 -',  "\n");
    $fhandle->print(' atom rdiel switch eps 1.0 e14fac 0.4 cutnb 7.0 ctonnb 6.0 ctofnb 6.5 -',  "\n");
    $fhandle->print(' nbxmod 5 vswitch wmin 0.0 vatom vdistance',  "\n");
    $fhandle->print(  "\n");
    $fhandle->print('!fix everything except OMEGA, Zoffset, R0, PHI and w0',  "\n");
    $fhandle->print('cons fix sele .not. (segid c .or. segid e .or. segid f) end',  "\n");
    $fhandle->print(  "\n");
    $fhandle->print('!optimize Crick parameters',  "\n");
    $fhandle->print(' mini sd nstep 200 step 0.10 nprint 10 ihbfrq 25 inbfrq 25 -',  "\n");
    $fhandle->print(' atom rdiel switch eps 1.0 e14fac 0.4 cutnb 7.0 ctonnb 6.0 ctofnb 6.5 -',  "\n");
    $fhandle->print(' nbxmod 5 vswitch wmin 0.0 vatom vdistance',  "\n");
    $fhandle->print(  "\n");
}




sub writeFitCrick {
    
   my $self=shift;
   my $fhandle=$self->{files}->{inp};

   my $r0=shift;
   my $phi=shift;
   my $w0=shift;

   $fhandle->print('!use all energy terms except elec (includes user energy and hbonds)',  "\n");
   $fhandle->print('skip elec ',  "\n");
   $fhandle->print(  "\n");
   $fhandle->print('!specify desired Crick values here, if different from input',  "\n");
   $fhandle->print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!',  "\n");
   $fhandle->print('!segid c - x:  OMEGA (angular displacement of superhelix in space)',  "\n");
   $fhandle->print('!segid c - z:  Zoffset (Z displacement of superhelix in space)',  "\n");
   $fhandle->print('!segid d - x:  10d (ten times alpha helix pitch)',  "\n");
   $fhandle->print('!segid d - z:  R1 (alpha helix radius)',  "\n");
   $fhandle->print('!segid e - x:  R0 (super helix radius)',  "\n");
   $fhandle->print('!segid e - z:  PHI (angular coordinate for a CA)',  "\n");
   $fhandle->print('!segid f - x:  10w0 (ten times superhelix frequency in rad/res)',  "\n");
   $fhandle->print('!segid f - z:  dU/dR if positive and < 90; 2*k (framework f.c.) if < -1',  "\n");
   $fhandle->print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!',  "\n");
   $fhandle->print(  "\n");
   $fhandle->print('! alpha helix parameters usually do not change',  "\n");
   $fhandle->print('!scal x set 15.2 sele segid d end',  "\n");
   $fhandle->print('!scal z set -2.26 sele segid d end',  "\n");
   $fhandle->print('! set R0, phi and w0 here',  "\n");
   $fhandle->print("scal x set $r0 sele segid e end \n");
   $fhandle->print("scal z set $phi sele segid e end\n");
   $fhandle->print("scal x set $w0 sele segid f end n");
   $fhandle->print(  "\n");
   $fhandle->print('!constrain the Crick parameters at desired values (except OMEGA and Zoffset)',  "\n");
   $fhandle->print('cons fix sele segid d .or. segid f .or. segid e end',  "\n");
   $fhandle->print(  "\n");
   $fhandle->print('!minimize geometry - I have not optimized this scheme',  "\n");
   $fhandle->print('mini sd nstep 600 step 0.10 nprint 10 ihbfrq 25 inbfrq 25 -',  "\n");
   $fhandle->print('  atom rdiel switch eps 1.0 e14fac 0.4 cutnb 7.0 ctonnb 6.0 ctofnb 6.5 -',  "\n");
   $fhandle->print('  nbxmod 5 vswitch wmin 0.0 vatom vdistance',  "\n");
   $fhandle->print(  "\n");
   $fhandle->print('mini abnr nstep 400 step 0.01 nprint 10 ihbfrq 25 inbfrq 25 -',  "\n");
   $fhandle->print('  atom rdiel switch eps 1.0 e14fac 0.4 cutnb 7.0 ctonnb 6.0 ctofnb 6.5 -',  "\n");
   $fhandle->print('  nbxmod 5 vswitch wmin 0.0 vatom vdistance',  "\n");
   $fhandle->print(  "\n");
   $fhandle->print('!both routines end by priting out optimized files in both pdb and crd:',  "\n");
   $fhandle->print('! the crd file contains the crick params and is a pain in rasmol',  "\n");
   $fhandle->print(  "\n");
}

=head2

 Title   :  readCHARMMTopology
 Usage   :  my $T = CHARMM::readCHARMMTopology("toph19.inp");
 Function:  Parses a CHARMM topology file and returns a topology structure.
 Returns :  Hash reference.
 Args    :  1. Topology file name.
            2. Optional: a pointer to a pre-existing topology structure, in which case it will be appended with new topology information.

=cut

sub readCHARMMTopology {
  my $topf = shift;
  GENERAL::requireArgs($topf);
  my $Tp = shift;

  my %T; 
  if (!defined($Tp)) {
    $Tp = \%T;
    $Tp->{residues} = ();
  }
  my $res = -1;
  my $g = 0; # group number: 0 means outside of the first group statement
  my $ifh = GENERAL::GetInFH($topf);
  while (<$ifh>) {
    $_ =~ s/\!.*$//g; # remove comments
    $_ = GENERAL::Trim($_);
    if ($_ =~ /^\s*(PRES|RESI) (\S+)\s+(\S+)\s*/) {
      if (!defined($2)) {
        GENERAL::error("Error parsing line \"$_\" - residue name not found!");
      }
      $res = ();
      $res->{name} = $2;
      $res->{charge} = $3;
      $res->{atoms} = (); # atoms hash
      $res->{atoma} = (); # atoms array
      $res->{groups} = ();
      $res->{bonds} = ();
      $Tp->{residues}->{$2} = $res;
      $res->{patchf} = ($_ =~ /^\s*PRES/) ? 1 : 0;
      $g = 0;
      next;
    }
    if ($res eq -1) { next; }
    if (/GROU/) {
      $g++;
    } elsif ($_ =~ /^\s*ATOM\s+(\S+)\s+(\S+)\s+(\S+)(\s|\Z)/) {
      if (!defined($1) || !defined($2) || !defined($3)) {
        GENERAL::error("Error parsing line \"$_\" - not all atom attributes found!");
      }
      my $atom = ();
      $atom->{name} = $1;
      $atom->{group} = $g;
      $atom->{type} = $2;
      $atom->{charge} = $3;
      $res->{atoms}->{$1} = $atom;
      push(@{$res->{atoma}}, $atom);
      if (!defined($res->{groups}->{$g})) {
        $res->{groups}->{$g} = ();
      }
      push(@{$res->{groups}->{$g}}, $atom);
    } elsif ($_ =~ /^\s*(BOND|DOUBLE)/) {
      my @arr = split(" ", $_);
      my $tmp = shift @arr; if ($tmp !~ /^(BOND|DOUBLE)$/) { GENERAL::error("Parsing error on BOND line '$_' - BOND or DOUBLE is not the first keyword"); }
      if (scalar(@arr) % 2 != 0) { GENERAL::error("Parse error on BOND line '$_' - number of atoms is not even!"); }
      for (my $i = 0; $i < scalar(@arr); $i+=2) {
        $res->{bonds}->{$arr[$i]}->{$arr[$i+1]} = 1;
        $res->{bonds}->{$arr[$i+1]}->{$arr[$i]} = 1;
      }
    } elsif ($_ =~ /^\s*DELETE\s+ATOM\s+(\S+)\s*$/) {
      push(@{$res->{delete}}, $1);
    }
  }
  close($ifh);

  return $Tp;
}

=head2

 Title   :  readCHARMMParameters
 Usage   :  my $P = CHARMM::readCHARMMParameters("param19.inp");
 Function:  Parses a CHARMM parameter file and returns a parameter structure.
 Returns :  Hash reference.
 Args    :  1. Parameter file name.
            2. Read bonded parameters too (i.e. bonds, angles, dihedrals)? Default is no.

=cut

sub readCHARMMParameters {
  my $parf = shift;
  GENERAL::requireArgs($parf);
  my $bpf = shift; $bpf = 0 if (!defined($bpf));
  my %P;
  my $ifh = GENERAL::GetInFH($parf);
  my $line;

  # get bonds
  if ($bpf) {
    GENERAL::assert(GENERAL::skipTo($ifh, '^\s*BOND'), "BONDS section not found in parameter file $parf!");
    while (defined($line = CHARMM::nextCHARMMLine($ifh))) {
      last if ($line =~ /^\s*(ANGLES|THETAS)/);
      my @line = split(" ", $line);
      GENERAL::assert(scalar(@line) == 4, "incorrect number of tokens on bond line '$line'");
      $P{bond}{$line[0]}{$line[1]}{Kb} = $line[2]; $P{bond}{$line[1]}{$line[0]}{Kb} = $P{bond}{$line[0]}{$line[1]}{Kb};
      $P{bond}{$line[0]}{$line[1]}{b0} = $line[3]; $P{bond}{$line[1]}{$line[0]}{b0} = $P{bond}{$line[0]}{$line[1]}{b0};
    }

    # get angles
    while (defined($line = CHARMM::nextCHARMMLine($ifh))) {
      last if ($line =~ /^\s*(DIHEDRALS|PHI)/);
      my @line = split(" ", $line);
      GENERAL::assert(scalar(@line) >= 5, "incorrect number of tokens on angle line '$line'");
      $P{angl}{$line[0]}{$line[1]}{$line[2]}{Ktheta} = $line[3]; $P{angl}{$line[2]}{$line[1]}{$line[0]}{Ktheta} = $P{angl}{$line[0]}{$line[1]}{$line[2]}{Ktheta};
      $P{angl}{$line[0]}{$line[1]}{$line[2]}{Theta0} = $line[4]; $P{angl}{$line[2]}{$line[1]}{$line[0]}{Theta0} = $P{angl}{$line[0]}{$line[1]}{$line[2]}{Theta0};
      if (scalar(@line) > 5) {
        GENERAL::assert(scalar(@line) == 7, "incorrect number of tokens on angle line '$line'");
        $P{angl}{$line[0]}{$line[1]}{$line[2]}{Kub} = $line[5]; $P{angl}{$line[2]}{$line[1]}{$line[0]}{Kub} = $P{angl}{$line[0]}{$line[1]}{$line[2]}{Kub};
        $P{angl}{$line[0]}{$line[1]}{$line[2]}{S0} = $line[6]; $P{angl}{$line[2]}{$line[1]}{$line[0]}{S0} = $P{angl}{$line[0]}{$line[1]}{$line[2]}{S0};
      }
    }

    # get dihedrals
    while (defined($line = CHARMM::nextCHARMMLine($ifh))) {
      last if ($line =~ /^\s*(IMPROPER|IMPHI)/);
      my @line = split(" ", $line);
      GENERAL::assert(scalar(@line) == 7, "incorrect number of tokens on dihedral line '$line'");
      $P{dihe}{$line[0]}{$line[1]}{$line[2]}{$line[3]}{Kchi} = $line[4]; $P{dihe}{$line[3]}{$line[2]}{$line[1]}{$line[0]}{Kchi} = $P{dihe}{$line[0]}{$line[1]}{$line[2]}{$line[3]}{Kchi};
      $P{dihe}{$line[0]}{$line[1]}{$line[2]}{$line[3]}{n} = $line[5];  $P{dihe}{$line[3]}{$line[2]}{$line[1]}{$line[0]}{n} = $P{dihe}{$line[0]}{$line[1]}{$line[2]}{$line[3]}{n};
      $P{dihe}{$line[0]}{$line[1]}{$line[2]}{$line[3]}{delta} = $line[6]; $P{dihe}{$line[3]}{$line[2]}{$line[1]}{$line[0]}{delta} = $P{dihe}{$line[0]}{$line[1]}{$line[2]}{$line[3]}{delta};
    }

    # get impropers
    while (defined($line = CHARMM::nextCHARMMLine($ifh))) {
      if ($line =~ /^\s*(CMAP|NONBONDED)/) {
        GENERAL::assert(GENERAL::skipTo($ifh, '^\s*NONBONDED'), "NONBOND section not found in parameter file $parf!") if ($line =~ /CMAP/);
        last;
      }
      my @line = split(" ", $line);
      GENERAL::assert(scalar(@line) == 7, "incorrect number of tokens on improper line '$line'");
      $P{impr}{$line[0]}{$line[1]}{$line[2]}{$line[3]}{Kpsi} = $line[4]; $P{impr}{$line[3]}{$line[2]}{$line[1]}{$line[0]}{Kpsi} = $P{impr}{$line[0]}{$line[1]}{$line[2]}{$line[3]}{Kpsi};
      $P{impr}{$line[0]}{$line[1]}{$line[2]}{$line[3]}{n} = $line[5];  $P{impr}{$line[3]}{$line[2]}{$line[1]}{$line[0]}{n} = $P{impr}{$line[0]}{$line[1]}{$line[2]}{$line[3]}{n};
      $P{impr}{$line[0]}{$line[1]}{$line[2]}{$line[3]}{psi0} = $line[6]; $P{impr}{$line[3]}{$line[2]}{$line[1]}{$line[0]}{psi0} = $P{impr}{$line[0]}{$line[1]}{$line[2]}{$line[3]}{psi0};
    }
  } else {
    GENERAL::assert(GENERAL::skipTo($ifh, '^\s*NONBONDED'), "NONBOND section not found in parameter file $parf!");
  }

  # Get to NONBONDed parameters
  $P{vdW} = ();
  while (defined($_ = CHARMM::nextCHARMMLine($ifh))) {
    # assumes that HBOND and NBFIX specifications comes after the NBONDed specifications
    last if ($_ =~ m/(HBOND|NBFIX|END|hbond)/i);
    # parse vdW parameter line
    my @arr = split(" ", $_);
    if (scalar(@arr) < 4) {
      GENERAL::error("Parsing error on line \"$_\" - expected more elements on the line\n");
    }
    $P{vdW}{$arr[0]}{emin} = $arr[2];
    $P{vdW}{$arr[0]}{rmin} = $arr[3];
    if (scalar(@arr) >= 7) {
      $P{vdW}{$arr[0]}{emin_alt} = $arr[5];
      $P{vdW}{$arr[0]}{rmin_alt} = $arr[6];
    }
  }
  close($ifh);

  return \%P;
}


=head2

 Title   :  expandCHARMMParameters
 Usage   :  CHARMM::expandCHARMMParameters(\%Param_hash, \%Topology_hash);
 Function:  Some parameters in CHARMM parameter files are defined for more than one
            atom type by using asterisks in atom type names (such as O* means all
            oxygens). This function "expands" these atom types by looking at all
            atom types present in the topology hash and if any of them matching an
            "expandable" atom type from the parameter hash (an atom type with an asterisk),
            a new entry is made in the parameter hash with the full atom type name, which
            points to the same entry as the asterisked atom type.
 Returns :  Nothing
 Args    :  1. Parameter hash pointer.
            2. Topology hash pointer

=cut

sub expandCHARMMParameters {
  my $P = shift;
  my $T = shift;
  GENERAL::requireArgs($P, $T);

  # Find all atom types in the topology
  my @types;
  foreach my $rn (keys(%{$T->{residues}})) {
    foreach my $an (keys(%{$T->{residues}->{$rn}->{atoms}})) {
      my $t =  $T->{residues}->{$rn}->{atoms}->{$an}->{type};
      my $f = 0;
      foreach my $at (@types) {
        if ($at eq $t) { $f = 1; last; }
      }
      if ($f == 0) {
        push(@types, $t);
      }
    }
  }

  # For each found type, find it in vdW parameter structure
  foreach my $at (@types) {
    # first, try to find the actual name
    my $f = 0;
    foreach my $pt (keys(%{$P->{vdW}})) {
      if ($pt eq $at) { $f = 1; last; }
    }
    next if ($f);
    # if not found, try to find an exandable name matching $at
    foreach my $pt (keys(%{$P->{vdW}})) {
      # if this is an exandable atom type, see if it matches
      if ($pt =~ /(\*|\%)/) {
        my $tmp = $pt;
        $tmp =~ s/[\*\%]//;
#printf("Looking for $at, trying $pt (matching $tmp)...\n");
        # if it does match, we need to make an instance in the parameter structure with the full atom name
        if ($at =~ /^$tmp/) {
#printf("$at is really a $pt (matched $tmp)...\n");
          $P->{vdW}{$at} = $P->{vdW}{$pt};
          $f = 1;
          last;
        }
      }
    }
  }

#   # For each wild card atom in the dihedral parameter structure, allow each of the found types
#   my $rep = 1;
#   while ($rep) {
#     $rep = 0;
#     foreach my $dihe (keys(%{$P->{dihe}})) {
#       if ($dihe =~ /X/) {
#         $rep++;
#         foreach my $at (@types) {
#           my $ndihe = $dihe;
#           $ndihe =~ s/X/$at/;
#           $P->{dihe}{$ndihe} = $P->{dihe}{$ndihe};
#         }
#         # now that wild card was filled in, get rid of wild-carded dihedral
#         delete($P->{dihe}{$dihe});
#       }
#     }
#   }

}


=head2

 Title   :  readEEFParameters
 Usage   :  my $P = CHARMM::readEEFParameters("solvpar.inp");
 Function:  Parses an EEF parameter file and returns a parameter structure.
 Returns :  Hash reference.
 Args    :  1. Parameter file name.

=cut

sub readEEFParameters {
  my $parf = shift;
  my $line;

  my %P;
  my $ifh = GENERAL::GetInFH($parf);
  while (defined($line = CHARMM::nextCHARMMLine($ifh))) {
    $line = GENERAL::Trim($line);
    my @arr = split(" ", $line);
    if (scalar(@arr) != 7) {
      GENERAL::error("Error parsing line \"$line\" - expected 7 elements!");
    }
    $P{$arr[0]}{V} = $arr[1];
    $P{$arr[0]}{Gref} = $arr[2];
    $P{$arr[0]}{Gfree} = $arr[3];
    $P{$arr[0]}{Href} = $arr[4];
    $P{$arr[0]}{CPref} = $arr[5];
    $P{$arr[0]}{SigW} = $arr[6];
  }
  close($ifh);
  
  return \%P;
}


=head2

 Title   :  getImprPar
 Usage   :  CHARMM::getImprPar(\%Param_hash, "C", "CR1E", "C", "CH2E");
 Function:  Finds and returns a matching improper dihedral entry in the CHARMM
            parameters hash passed as the first argument.
 Returns :  Improper dihedral parameter entry
 Args    :  1. Parameter hash pointer.
            2-5. Atom types of the four atoms composing the improper dihedral.
            6. optional: string flag; if set (not by default), will return undef upon failure, instead of quitting.

=cut

sub getImprPar {
  my $P = shift;
  my $at1 = shift;
  my $at2 = shift;
  my $at3 = shift;
  my $at4 = shift;
  my $strict = shift;
  $strict = 1 if (!defined($strict));

  foreach my $a1 ($at1, "X") {
    foreach my $a2 ($at2, "X") {
      foreach my $a3 ($at3, "X") {
        foreach my $a4 ($at4, "X") {
          if (defined($P->{impr}{$a1}{$a2}{$a3}{$a4})) {
            return $P->{impr}{$a1}{$a2}{$a3}{$a4};
          }
        }
      }
    }
  }
  my $mes = "Could not find improper dihedral '$at1 - $at2 - $at3 - $at4' in the set of parameters";
  if ($strict == 1) { GENERAL::error($mes); }
  elsif ($strict == 0) { GENERAL::warning($mes); }
  return undef;
}

=head2

 Title   :  getDihePar
 Usage   :  CHARMM::getDihePar(\%Param_hash, "CH1E", "C", "N", "CH1E");
 Function:  Finds and returns a matching dihedral entry in the CHARMM
            parameters hash passed as the first argument.
 Returns :  Dihedral parameter entry
 Args    :  1. Parameter hash pointer.
            2-5. Atom types of the four atoms composing the dihedral.
            6. optional: string flag; if set (not by default), will return undef upon failure, instead of quitting.

=cut

sub getDihePar {
  my $P = shift;
  my $at1 = shift;
  my $at2 = shift;
  my $at3 = shift;
  my $at4 = shift;
  my $strict = shift;
  $strict = 1 if (!defined($strict));

  foreach my $a1 ($at1, "X") {
    foreach my $a2 ($at2, "X") {
      foreach my $a3 ($at3, "X") {
        foreach my $a4 ($at4, "X") {
          if (defined($P->{dihe}{$a1}{$a2}{$a3}{$a4})) {
            return $P->{dihe}{$a1}{$a2}{$a3}{$a4};
          }
        }
      }
    }
  }
  my $mes = "Could not find dihedral '$at1 - $at2 - $at3 - $at4' in the set of parameters";
  if ($strict == 1) { GENERAL::error($mes); }
  elsif ($strict == 0) { GENERAL::warning($mes); }
  return undef;
}


=head2

 Title   :  getAnglPar
 Usage   :  CHARMM::getAnglPar(\%Param_hash, "CH1E", "C", "N");
 Function:  Finds and returns a matching bond angle entry in the CHARMM
            parameters hash passed as the first argument.
 Returns :  Bond angle entry
 Args    :  1. Parameter hash pointer.
            2-4. Atom types of the four atoms composing the bond angle.

=cut

sub getAnglPar {
  my $P = shift;
  my $at1 = shift;
  my $at2 = shift;
  my $at3 = shift;
  my $strict = shift;
  $strict = 1 if (!defined($strict));

  foreach my $a1 ($at1, "X") {
    foreach my $a2 ($at2, "X") {
      foreach my $a3 ($at3, "X") {
        if (defined($P->{angl}{$a1}{$a2}{$a3})) {
          return $P->{angl}{$a1}{$a2}{$a3};
        }
      }
    }
  }
  my $mes = "Could not find bond '$at1 - $at2 - $at3' in the set of parameters";
  if ($strict == 1) { GENERAL::error($mes); }
  elsif ($strict == 0) { GENERAL::warning($mes); }
  return undef;
}


=head2

 Title   :  getBondPar
 Usage   :  CHARMM::getBondPar(\%Param_hash, "CH1E", "N");
 Function:  Finds and returns a matching bond angle entry in the CHARMM
            parameters hash passed as the first argument.
 Returns :  Bond angle entry
 Args    :  1. Parameter hash pointer.
            2-4. Atom types of the four atoms composing the bond angle.

=cut

sub getBondPar {
  my $P = shift;
  my $at1 = shift;
  my $at2 = shift;
  my $strict = shift;
  $strict = 1 if (!defined($strict));

  foreach my $a1 ($at1, "X") {
    foreach my $a2 ($at2, "X") {
      if (defined($P->{bond}{$a1}{$a2})) {
        return $P->{bond}{$a1}{$a2};
      }
    }
  }
  my $mes = "Could not find bond '$at1 - $at2' in the set of parameters";
  if ($strict == 1) { GENERAL::error($mes); }
  elsif ($strict == 0) { GENERAL::warning($mes); }
  return undef;
}

=head2

 Title   :  nextCHARMMLine
 Usage   :  my $P = CHARMM::nextCHARMMLine($input_file_handle);
 Function:  Reads the next line in a CHARMM file (parameter/topology or script). Basically
            knows to include the next line if the "-" character is placed at the end.
 Returns :  String
 Args    :  1. Input file handle
            2. Optional flag: through away comments? By default does.
            3. Optional flag: through title lines? By default does.
            4. Optional flag: through empty lines? By default does.

=cut

sub nextCHARMMLine {
  my $fh = shift;
  my $com = shift;
  if (!defined($com)) { $com = 1; }
  my $emp = shift;
  if (!defined($emp)) { $emp = 1; }
  my $ttl = shift;
  if (!defined($ttl)) { $ttl = 1; }
  my $line = undef;

  while (<$fh>) {
    $_ = GENERAL::Trim($_);
    if ($com && ($_ =~ /!/)) { # ignore comments
      $_ =~ s/!.*$//g; $_ = GENERAL::Trim($_);
      if ($_ eq "") { next; }
    }
    if ($ttl && ($_ =~ /^\*/)) { next; } # ignore title lines
    if ($emp && ($_ =~ /^\s*$/)) { next; } # ignore empty lines
    if ($_ =~ /^(.*)-\s*$/) {
      $line .= "$1 ";
    } else {
      $line .= $_;
      last;
    }
  }

  return $line;
}


=head2

 Title   :  parseAnalysis
 Usage   :  my $P = CHARMM::parseAnalysis($analysis_file);
 Function:  Parses the output produced by the CHARMM interaction analysis tool.
 Returns :  Reference to a double hash (by interacting atom names) containing
            distances and interaction energies. If energies are "infinite" (i.e.
            ***** in output), they are replaced with 9999.
 Args    :  1. Analysis file

=cut

sub parseAnalysis {
  my $file = shift;
  my %A;

  my $fh = GENERAL::GetInFH($file);
  while (<$fh>) {
    next if ($_ !~ /ANAL\:  VDW\>/);

    # get atom indices
    $_ = GENERAL::Trim($_);
    my @att = split(" ", $_);
    if (scalar(@att) != 13) {
      GENERAL::error("Could not parse line \"$_\" of analysis - unexpected number of elements");
    }
#    my $ai = $att[3]; # atom numbers
#    my $aj = $att[8]; # atom numbers
    my $ai = "$att[4]\_$att[6]\_$att[5]\_$att[7]"; # string compatible with PDB::atomStr
    my $aj = "$att[9]\_$att[11]\_$att[10]\_$att[12]";
    
    # make sure pairs are always stored in the same direction
    if ($aj lt $ai) { my $tmp = $aj; $aj = $ai; $ai = $tmp; }

    # get distance and energy
    $_ = <$fh>;
    my $d = substr($_, 0, 15) + 0;
    my $vdw = substr($_, 15, 15);
    if ($vdw =~ /\*/) { $vdw = 9999; }
    $vdw += 0;
    
    $A{$ai}{$aj}{dist} = $d;
    $A{$ai}{$aj}{vdw} = $vdw;
  }
  close($fh);

  if (scalar(keys(%A)) == 0) {
    GENERAL::error("Could not parse analysis file $file - it seems to be empty");
  }
  return \%A;
}


=head2

 Title   :  sanitizeFilename
 Usage   :  my $goodFileName = CHARMM::sanitizeFilename($badFileName);
            my $goodFileName = CHARMM::sanitizeFilename($badFileName, \@keepTrackOfAllSanitizedFileNamesList);
 Function:  Converts the specified file name into something that CHARMM can write.
 Returns :  A string representing a CHARMM-sanitized version of the file name.
 Args    :  1. file name string

=cut

sub sanitizeFilename {
  my $file = shift;
  my $list = shift;
  my $ofile = $file;
  $file =~ s/:/-pp-/g;
  $file = lc($file);
  push(@$list, GENERAL::arrayRef($file, $ofile)) if (defined($list) && ($file ne $ofile));
  return $file;
}

1;
