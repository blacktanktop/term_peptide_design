# By Gevorg Grigoryan

package NAMD;
$DEF_VER_CONTROL->{date}->{NAMD} = "12/08/2009";

use strict;
use GENERAL;
use PDB;
use DEFINITIONS;
use Text::Wrap;
use IPC::Open2;
use IO::Handle;
use IO::File;
use IO::Select;
use Scalar::Util;
use POSIX ":sys_wait_h";

=head2

 Title   :  new
 Usage   :  my $namd = NAMD::new("/usr/bin/namd2")
            my $namd = NAMD::new("/usr/bin/namd2", "script.ctl", "script.out")
 Function:  NAMD object constructor.
 Returns :  none
 Args    :  1. NAMD executable to use
            2. Optional: input control file
            3. Optional: output log file

=cut

sub new {
  my $self = {};
  my %par = @_;
  GENERAL::assert(defined($par{exec}), "Need to defined at least the NAMD executable");

  my $logcmdfile = $par{cmdfile};
  my $logoutfile = $par{outfile};
  my $keepoutlog = $par{keepout};
  if (!defined($keepoutlog)) { $keepoutlog = 0; }

  # default control and output files
  if (!defined($logcmdfile)) {
    if (defined($LOCAL_DEF)) {
      $logcmdfile = "$LOCAL_DEF/_$$\_namd.ctl";
    } else {
      $logcmdfile = "/tmp/_$$\_namd.ctl";
    }
  }
  $logoutfile = (GENERAL::GetBase($logcmdfile) . ".out") if (!defined($logoutfile));

  bless $self;
  $self->{handles} = {};
  $self->{inter} = 0;

  # open script log file if necessary
  $self->{handles}->{cmdlog} = GENERAL::GetOutFH($logcmdfile);
  $self->{handles}->{cmdlog}->autoflush(1);
  $self->{files}->{cmdlog} = $logcmdfile;
  $self->{run} = 0;

  $self->{files}->{outlog} = $logoutfile;
  $self->{keepoutlog} = $keepoutlog;

  GENERAL::assert(defined(-x $par{exec}), "NAMD binary '$par{exec}' not executable");
  $self->{namd_bin} = defined($par{exec}) ? $par{exec} : "/home/grigoryanlab/library/bin/namd2";
  $self->{vmd_bin} = defined($par{vmd_bin}) ? $par{vmd_bin} : "/home/grigoryanlab/local/bin/vmd";

  # set up writing streams for NAMD
  if ($self->{inter}) {
    GENERAL::error("Do not yet know how to work with NAMD interactively!");
  } else {
    $self->{_namdpid} = "non-interactive";
    $self->{handles}->{tonamd} = $self->{handles}->{cmdlog};
  }

  # send title to begin script
  my $date = GENERAL::GetTime();
  my $mac = GENERAL::GetMachine();
  my $dir = GENERAL::GetDir();
  $self->send(Text::Wrap::wrap("# ", "# ", "NAMD control script Generated by PROCEDE Package\nDate: $date, machine: $mac, directory: $dir")."\n\n");

  # single or multi-processor?
  if (defined($par{np}) && ($par{np} > 1)) {
    if (!defined($par{multicore}) || ($par{multicore} eq 0)) {
      GENERAL::assert(defined($par{charmrun}), "Must defined charmrun executable for mutl-processor runs");
      GENERAL::assert(-x $par{charmrun}, "NAMD binary '$par{charmrun}' not executable");
      $self->{charmrun_bin} = $par{charmrun};
      $self->{multicore} = 0;
    } else {
      $self->{multicore} = 1;
    }
    $self->{parallel} = 1;
    $self->{NP} = $par{np};
  } else {
    $self->{parallel} = 0;
  }

  # setup default parameters
  $self->resetParams();
  $self->resetCommands();

  # order of parameter types
  return $self;
}

DESTROY {
  my $self = shift;

  $self->finish() if (!defined $self->{_finished} || !$self->{_finished});
}


=head2

 Title   :  send
 Usage   :  $namd->send("ic paral all");
 Function:  Write command to control file.
 Returns :  String or a list of strings (which will be concatenated) containing the command(s).
 Args    :  1. String

=cut

sub send {
  my $self = shift;
  my $txt = join("",@_);

  $self->{handles}->{tonamd}->print("$txt");
}

=head2

 Title   :  command
 Usage   :  $namd->command("run 100000");
 Function:  Appends the given string to the commands section (always goes last in the final script)
 Returns :  Nothing
 Args    :  1. String

=cut

sub command {
  my $self = shift;
  my $txt = shift;
  my $group = shift;
  my $name = shift;
  GENERAL::assert($self->isParameter($group, $name)) if (defined($group) && defined($name));
  $name = "_COMMON" if (defined($group) && (!defined($name))); # if no parameter name is specified, the command is for the whole section

  if (defined($group) && defined($name)) {
    $self->{params}->{$group}->{$name}->{commands} = "" if (!defined($self->{params}->{$group}->{$name}->{commands}));
    $self->{params}->{$group}->{$name}->{commands} .= $txt . "\n";
  } else {
    $self->{commands} .= $txt . "\n";
  }
}

=head2

 Title   :  resetCommands
 Usage   :  $namd->resetCommands();
 Function:  Clears the commands section (always goes last in the final script)
 Returns :  Nothing
 Args    :  1. String

=cut

sub resetCommands {
  my $self = shift;

  $self->{commands} = "";
}

=head2

 Title   :  resetParams
 Usage   :  $namd->resetParams();
 Function:  Resets all parameters to their default values;
 Returns :  Nothing
 Args    :  1. String

=cut

sub resetParams {
  my $self = shift;

  $self->{params} = ();
  $self->{paramGroupOrder} = ();
  $self->{paramOrder} = ();

  $self->appendParameter("variables", "set temperature", 298.15, "temperature in Kelvin", "default_f", 1);
  $self->appendParameter("variables", "set jobname", GENERAL::GetBase($self->{files}->{cmdlog}), "job name", "default_f", 1);
  $self->appendParameter("variables", "set outname", '${jobname}.namdout', "base name for output files", "default_f", 1);

  $self->appendParameter("forcefield", "paraTypeCharmm", "on", undef, "default_f", 1);
  $self->appendParameter("forcefield", "parameters", DEFINITIONS::getParmFile("par_all22_prot.inp", "unknown"), undef, "default_f", 1);
  $self->appendParameter("forcefield", "exclude", "scaled1-4", undef, "default_f", 1);
  $self->appendParameter("forcefield", "1-4scaling", 1, undef, "default_f", 1);
  $self->appendParameter("forcefield", "cutoff", 12.0, undef, "default_f", 1);
  $self->appendParameter("forcefield", "switching", "on", undef, "default_f", 1);
  $self->appendParameter("forcefield", "switchdist", 10.0, undef, "default_f", 1);
  $self->appendParameter("forcefield", "pairlistdist", 13.5, undef, "default_f", 1);

  $self->appendParameterGroup("restart");
  $self->command("set restart 0", "restart");

  $self->appendParameter("initialization", "temperature", "\$temperature", undef, "default_f", 1);

  $self->appendParameter("integrator", "timestep", 1.0, "time step in fs", "default_f", 1);
  $self->appendParameter("integrator", "rigidBonds", "all", "needs to be 'all' for 2 fs/step", "default_f", 1);
  $self->appendParameter("integrator", "nonbondedFreq", 1, undef, "default_f", 1);
  $self->appendParameter("integrator", "fullElectFrequency", 1, undef, "default_f", 1);
  $self->appendParameter("integrator", "stepspercycle", 20, undef, "default_f", 1);

  $self->appendParameter("simulation", "langevin", "on", "do Langevin dynamics?", "default_f", 1);
  $self->appendParameter("simulation", "langevinDamping", 5, "damping coefficient (gamma), e.g. 5/ps", "default_f", 1);
  $self->appendParameter("simulation", "langevinTemp", "\$temperature", undef, "default_f", 1);
  $self->appendParameter("simulation", "langevinHydrogen", "off", "couple Langevin bath to hydrogens?", "default_f", 1);

  $self->appendParameter("io", "outputName", '$outname', undef, "default_f", 1);
  $self->appendParameter("io", "outputEnergies", 100, undef, "default_f", 1);

  # clean restraints
  delete($self->{restraints}) if (defined($self->{restraints}));
}

=head2

 Title   :  append/prepend parameter groups and parameters
 Usage   :  $namd->appendParameter("forcefield", "exclude", "scaled1-4")
 Function:  Grows the list of parameters and parameter groups. Append/prepend determines
            the order in which parameter groups and individual parameter values will be printed
            into the eventual NAMD control file.
 Returns :  none
 Args    :  1. NAMD executable to use
            2. parameter group name
            3. parameter name within this group (for parameter-specific functions)
            4. parameter value (for parameter-specific functions)

=cut

sub appendParameter {
  my $self = shift;
  my $group = shift;
  my $name = shift;
  my $value = shift;
  my $comment = shift;
  my %addtl = @_;

  $self->appendParameterGroup($group) if (!$self->isParameterGroup($group));
  if (!$self->isParameter($group, $name)) {
    $self->{params}->{$group}->{$name}->{value} = $value;
    $self->{params}->{$group}->{$name}->{comment} = $comment if (defined($comment));
    foreach my $k (keys(%addtl)) {
      $self->{params}->{$group}->{$name}->{$k} = $addtl{$k};
    }
    push(@{$self->{paramOrder}->{$group}}, $name);
  } else {
    GENERAL::error("Group '$group', variable '$name' already exists!");
  }
}
sub setParameter {
  my $self = shift;
  my $group = shift;
  my $name = shift;
  my $value = shift;
  my $comment = shift;

  if (!$self->isParameter($group, $name)) {
    GENERAL::error("Group '$group', variable '$name' does not yet exists!");
  }
  $self->{params}->{$group}->{$name}->{value} = $value;
  $self->{params}->{$group}->{$name}->{comment} = $comment if (defined($comment));
  $self->{params}->{$group}->{$name}->{default_f} = 0;
}
sub removeParameterValue {
  my $self = shift;
  my $group = shift;
  my $name = shift;

  if (!$self->isParameter($group, $name)) {
    GENERAL::error("Group '$group', variable '$name' does not yet exists!");
  }
  delete $self->{params}->{$group}->{$name}->{value};
  delete $self->{params}->{$group}->{$name}->{comment} if (defined($self->{params}->{$group}->{$name}->{comment}));
}
sub appendParameterGroup {
  my $self = shift;
  my $group = shift;

  if (!$self->isParameterGroup($group)) {
    $self->{params}->{$group} = {};
    push(@{$self->{paramGroupOrder}}, $group);
  } else {
    GENERAL::error("Group '$group' already exists!");
  }
}
sub prependParameterGroup {
  my $self = shift;
  my $group = shift;

  if (!$self->isParameterGroup($group)) {
    $self->{params}->{$group} = {};
    unshift(@{$self->{paramGroupOrder}}, $group);
  } else {
    GENERAL::error("Group '$group' already exists!");
  }
}
sub placeParameterGroupAfter {
  my $self = shift;
  my $group = shift;
  my $agroup = shift;
  GENERAL::assert(!$self->isParameterGroup($group), "Group '$group' already exists!");
  GENERAL::assert($self->isParameterGroup($agroup), "Group '$agroup' does not exist, so cannot place group '$group' after!");
  my $idx = GENERAL::findin($agroup, @{$self->{paramGroupOrder}});
  splice(@{$self->{paramGroupOrder}}, $idx+1, 0, $group);
  $self->{params}->{$group} = {};
}
sub isParameterGroup {
  my $self = shift;
  my $group = shift;

  return defined($self->{params}->{$group});
}
sub isParameter {
  my $self = shift;
  my $group = shift;
  my $name = shift;

  return (defined($self->{params}) && defined($self->{params}->{$group}) && defined($self->{params}->{$group}->{$name}));
}
sub isDefault {
  my $self = shift;
  my $group = shift;
  my $name = shift;

  return ($self->isParameter($group, $name) && defined($self->{params}->{$group}->{$name}->{default_f}) && $self->{params}->{$group}->{$name}->{default_f});
}
sub getParameterValue {
  my $self = shift;
  my $group = shift;
  my $name = shift;

  return $self->{params}->{$group}->{$name}->{value};
}
sub setOutLogFile {
  my $self = shift;
  my $outlog = shift;
  GENERAL::requireArgs($self, $outlog);
  $self->{files}->{outlog} = $outlog;
}


=head2

 Title   :  addProcedure
 Usage   :  $namd->addProcedure("stupid", "while {1} { }");
 Function:  Adds a procedure to the list of procs.
 Returns :  Nothing
 Args    :

=cut

sub addProcedure {
  my $self = shift;
  my $name = shift;
  my $proc = shift;
  GENERAL::requireArgs($self, $name, $proc);
  GENERAL::assert(!$self->isProcedure($name), "Procedure $name already defined!");

  $self->{procs}->{$name}->{code} = $proc;
}
sub isProcedure {
  my $self = shift;
  my $name = shift;
  return defined($self->{procs}->{$name}) && defined($self->{procs}->{$name}->{code});
}

=head2

 Title   :  flush
 Usage   :  $namd->flush();
 Function:  Flushes NAMD output streams.
 Returns :  Nothing
 Args    :

=cut

sub flush {
  my $self = shift;
  $self->{handles}->{tonamd}->flush();
}


=head2

 Title   :  _closeAll
 Usage   :  $namd->_closeAll();
 Function:  Closes all handles
 Returns :  Nothing
 Args    :  None

=cut

sub _closeAll {
  my $self = shift;

  close ($self->{handles}->{tonamd});
}

=head2

 Title   :  reOpen
 Usage   :  $namd->reOpen()
 Function:  Re-opens the output stream, if it was closed (like if one run with this object already hapenned)
 Returns :  Nothing
 Args    :  None

=cut

sub reOpen {
  my $self = shift;

  if (!defined(fileno($self->{handles}->{tonamd}))) {
    $self->{handles}->{cmdlog} = GENERAL::GetOutFH($self->{files}->{cmdlog});
    $self->{handles}->{tonamd} = $self->{handles}->{cmdlog};
  }
}

=head2

 Title   :  finish
 Usage   :  $namd->finish();
 Function:  Stops NAMD and closes the connection and all log files.
 Returns :  Nothing
 Args    :  None.

=cut

sub finish {
  my $self = shift;
  my $err_check = shift;
  $err_check = 1 if (!defined($err_check));

  # close all file handles
  $self->_closeAll();

  # clean up files
  if ((defined($self->{files}->{outlog})) && (-e $self->{files}->{outlog})) {
    if ($err_check) {
      my $err = `grep -i \"FATAL ERROR\" $self->{files}->{outlog}`;
      chomp($err);
      if ($err =~ /\S/) {
        $self->error("NAMD failed: fatal error message found in output.");
      }
    }
    GENERAL::crm($self->{files}->{outlog}) unless ($self->{keepoutlog});
  }
  $self->{_finished} = 1;
}

=head2

 Title   :  reset
 Usage   :  $namd->reset();
 Function:  Resets the object
 Returns :  Nothing
 Args    :  None.

=cut

sub reset {
  my $self = shift;

  $self->_closeAll();
  $self->reOpen();
  $self->resetParams();
}

=head2

 Title   :  resetRuns
 Usage   :  $namd->resetRuns();
 Function:  Resets all the previous runs of this object, but not the parameters of configs (e.g.
            if one needs to re-run the same thing)
 Returns :  Nothing
 Args    :  None.

=cut

sub resetRuns {
  my $self = shift;

  $self->_closeAll();
  $self->{run} = 0; # reset run counter
  GENERAL::csystem("rm " . $self->getParameterValue("variables", "set outname") . "*"); # remove all output files
  $self->reOpen(); # the control file will be properly written next time the object is run, just as it would the first time
}

sub error {
  my $self = shift;
  my $msg = shift;

  $self->_closeAll();
  if (defined($self->{files}->{cmdlog})) { $msg .= " Input in $self->{files}->{cmdlog}."; }
  if (defined($self->{files}->{outlog})) { $msg .= " Output in $self->{files}->{outlog}."; }
  $self->{_finished} = 1;
  GENERAL::error($msg);
}

sub runNAMD {
  my $self = shift;

  $self->{run} = 0 if (!defined($self->{run}));
  if ($self->{run} == 0) {
    $self->writeCTLFile();
  }
  $self->{run}++;

  # run NAMD
  GENERAL::csystem("echo 'STARTING RUN NUMBER $self->{run}' >> $self->{files}->{outlog}");
  if ($self->{parallel}) {
    # can use +setcpuaffinity flag for NAMD to prevent processes from migrating between cores
    if ($self->{multicore} eq 0) {
      return system("$self->{charmrun_bin} +p$self->{NP} $self->{namd_bin} $self->{files}->{cmdlog} >> $self->{files}->{outlog} 2>>$self->{files}->{outlog}");
    } else {
      return system("$self->{namd_bin} +p$self->{NP} $self->{files}->{cmdlog} >> $self->{files}->{outlog} 2>>$self->{files}->{outlog}");
    }
  } else {
    return system("$self->{namd_bin} $self->{files}->{cmdlog} >> $self->{files}->{outlog} 2>>$self->{files}->{outlog}");
  }
}


=head2

 Title   :  writeCTLFile
 Usage   :  $namd->writeCTLFile();
 Function:  Dumps all settings and commands to the control file, and closes it.
 Returns :  Nothing
 Args    :

=cut

sub writeCTLFile {
  my $self = shift;

  # write procs
  foreach my $pname (keys(%{$self->{procs}})) {
    $self->send("# -- $pname procedure\n" . $self->{procs}->{$pname}->{code} . "\n");
  }

  # write parameters
  foreach my $group ((@{$self->{paramGroupOrder}})) {
    $self->send("# -- $group parameters\n");
    foreach my $param (@{$self->{paramOrder}->{$group}}) {
      if (defined($self->{params}->{$group}->{$param}->{value})) {
        my $val = $self->{params}->{$group}->{$param}->{value};
        my $comment = (defined($self->{params}->{$group}->{$param}->{comment}) ? "; # $self->{params}->{$group}->{$param}->{comment}" : "");
        if (ref($val) eq "ARRAY") {
          foreach my $oneval (@$val) {
            $self->send(sprintf("$param $oneval%s\n", $comment));
          }
        } else {
          $self->send(sprintf("$param $val%s\n", $comment));
        }
      }
      if (defined($self->{params}->{$group}->{$param}->{commands})) {
        $self->send("# ---- $group/$param commands\n" . $self->{params}->{$group}->{$param}->{commands});
      }
    }
    if (defined($self->{params}->{$group}->{_COMMON}->{commands})) {
      $self->send("# --- $group commands\n" . $self->{params}->{$group}->{_COMMON}->{commands});
    }
    $self->send("\n");
  }

  # write restraints
  $self->writeRestraints();

  # write commands
  $self->send("#-- COMMANDS\n" . $self->{commands} . "\n");

  # close control file
  $self->_closeAll();
}

=head2

 Title   :  addDihedralRestraint
 Usage   :  $namd->addDihedralRestraint("A 16 N", "A 16 CA", "A 16 CB", "A 16 CG", $low_bound, $upper_bound, $force_const);
 Function:  Establishes a dihedral harmonic restraint
 Returns :  Nothing
 Args    :  1. String selection for atom 1
            2. String selection for atom 2
            3. String selection for atom 3
            4. String selection for atom 4
            5. Lower bound value of dihedral, in degrees (in the "positive direction in counter-clockwise sense")
            6. Upper bound value of dihedral, in degrees (in the "positive direction in counter-clockwise sense")
            7. Force constant in kcal/mol/degree^2
            8. optional: additional 'property', 'value' pairs. Currently possible values are:
               'integrate'   -   0/1, whether this variable should be used for integration
               'margin'      -   margin for defining the boundaries where the potential picks up (e.g. instead of LB/UB, the potential will act on LB-margin, UB+margin

=cut

sub addDihedralRestraint {
  my $self = shift;
  my $a1 = shift;
  my $a2 = shift;
  my $a3 = shift;
  my $a4 = shift;
  my $lb = shift;
  my $ub = shift;
  my $fc = shift;
  GENERAL::requireArgs($self, $a1, $a2, $a3, $a4, $lb, $ub, $fc);
  my %prop = @_;
  GENERAL::assert(($lb >= -180) && ($lb <= 180), "Invalid lower bound for dihedral: '$lb'");
  GENERAL::assert(($ub >= -180) && ($ub <= 180), "Invalid upper bound for dihedral: '$ub'");

  my %r;
  push(@{$r{"atoms"}}, $a1);
  push(@{$r{"atoms_vmd"}}, NAMD::toVMDsel($a1));
  push(@{$r{"atoms"}}, $a2);
  push(@{$r{"atoms_vmd"}}, NAMD::toVMDsel($a2));
  push(@{$r{"atoms"}}, $a3);
  push(@{$r{"atoms_vmd"}}, NAMD::toVMDsel($a3));
  push(@{$r{"atoms"}}, $a4);
  push(@{$r{"atoms_vmd"}}, NAMD::toVMDsel($a4));
  $r{"LB"} = $lb;
  $r{"UB"} = $ub;
  $r{"FC"} = $fc;
  $r{"type"} = "DIHE";
  $r{margin} = 0;
  foreach my $k (keys(%prop)) {
    $r{$k} = $prop{$k};
  }
  push(@{$self->{restraints}->{DIHE}}, \%r);
  push(@{$self->{restraints_in_order}}, \%r);
}

=head2

 Title   :  addAngleRestraint
 Usage   :  $namd->addAngleRestraint("A 16 N", "A 16 CA", "A 16 CB", $low_bound, $upper_bound, $force_const);
 Function:  Establishes an angular harmonic restraint
 Returns :  Nothing
 Args    :  1. String selection for atom 1
            2. String selection for atom 2
            3. String selection for atom 3
            5. Lower bound value of angle, in degrees (must be between 0 and 180)
            6. Upper bound value of angle, in degrees (must be between 0 and 180 and numerically above the lower bound)
            7. Force constant in kcal/mol/degree^2
            8. optional: additional 'property', 'value' pairs. Currently possible values are:
               'integrate'   -   0/1, whether this variable should be used for integration
               'margin'      -   margin for defining the boundaries where the potential picks up (e.g. instead of LB/UB, the potential will act on LB-margin, UB+margin

=cut

sub addAngleRestraint {
  my $self = shift;
  my $a1 = shift;
  my $a2 = shift;
  my $a3 = shift;
  my $lb = shift;
  my $ub = shift;
  my $fc = shift;
  GENERAL::requireArgs($self, $a1, $a2, $a3, $lb, $ub, $fc);
  my %prop = @_;
  GENERAL::assert(($lb >= 0) && ($lb <= 180), "Invalid lower bound for angle: '$lb'");
  GENERAL::assert(($ub >= 0) && ($ub <= 180), "Invalid upper bound for angle: '$lb'");
  GENERAL::assert($lb <= $ub, "Lower bound not <= upper bound: '$lb' and '$ub'");

  my %r;
  push(@{$r{"atoms"}}, $a1);
  push(@{$r{"atoms_vmd"}}, NAMD::toVMDsel($a1));
  push(@{$r{"atoms"}}, $a2);
  push(@{$r{"atoms_vmd"}}, NAMD::toVMDsel($a2));
  push(@{$r{"atoms"}}, $a3);
  push(@{$r{"atoms_vmd"}}, NAMD::toVMDsel($a3));
  $r{"LB"} = $lb;
  $r{"UB"} = $ub;
  $r{"FC"} = $fc;
  $r{"type"} = "ANGL";
  $r{margin} = 0;
  foreach my $k (keys(%prop)) {
    $r{$k} = $prop{$k};
  }
  push(@{$self->{restraints}->{ANGL}}, \%r);
  push(@{$self->{restraints_in_order}}, \%r);
}

=head2

 Title   :  addDistanceRestraint
 Usage   :  $namd->addDistanceRestraint("A 16 N", "A 16 CA", $low_bound, $upper_bound, $force_const);
 Function:  Establishes a harmonic distance restraint
 Returns :  Nothing
 Args    :  1. String selection for atom 1
            2. String selection for atom 2
            5. Lower bound value of distance (in Angstroms)
            6. Upper bound value of distance (in Angstroms; must be numerically above the lower bound)
            7. Force constant in kcal/mol/A^2
            8. optional: additional 'property', 'value' pairs. Currently possible values are:
               'integrate'   -   0/1, whether this variable should be used for integration
               'margin'      -   margin for defining the boundaries where the potential picks up (e.g. instead of LB/UB, the potential will act on LB-margin, UB+margin

=cut

sub addDistanceRestraint {
  my $self = shift;
  my $a1 = shift;
  my $a2 = shift;
  my $lb = shift;
  my $ub = shift;
  my $fc = shift;
  GENERAL::requireArgs($self, $a1, $a2, $lb, $ub, $fc);
  my %prop = @_;
  GENERAL::assert($lb <= $ub, "Lower bound not <= upper bound: '$lb' and '$ub'");

  my %r;
  push(@{$r{"atoms"}}, $a1);
  push(@{$r{"atoms_vmd"}}, NAMD::toVMDsel($a1));
  push(@{$r{"atoms"}}, $a2);
  push(@{$r{"atoms_vmd"}}, NAMD::toVMDsel($a2));
  $r{"LB"} = $lb;
  $r{"UB"} = $ub;
  $r{"FC"} = $fc;
  $r{"type"} = "DIST";
  $r{margin} = 0;
  foreach my $k (keys(%prop)) {
    $r{$k} = $prop{$k};
  }
  push(@{$self->{restraints}->{DIST}}, \%r);
  push(@{$self->{restraints_in_order}}, \%r);
}

=head2

 Title   :  addInplaceDistanceRestraint
 Usage   :  $namd->addInplaceDistanceRestraint("A 16 N", $xref, $yref, $zref, $low_bound, $upper_bound, $force_const);
 Function:  Establishes a flat-bottom harmonic distance restraint from a fixed point
 Returns :  Nothing
 Args    :  1. String selection for atom 1
            2-4. Reference coordinates x, y, z
            5. Lower bound value of distance (in Angstroms)
            6. Upper bound value of distance (in Angstroms; must be numerically above the lower bound)
            7. Force constant in kcal/mol/A^2
            8. optional: additional 'property', 'value' pairs. Currently possible values are:
               'integrate'   -   0/1, whether this variable should be used for integration
               'margin'      -   margin for defining the boundaries where the potential picks up (e.g. instead of LB/UB, the potential will act on LB-margin, UB+margin

=cut

sub addInplaceDistanceRestraint {
  my $self = shift;
  my $a = shift;
  my $xref = shift;
  my $yref = shift;
  my $zref = shift;
  my $lb = shift;
  my $ub = shift;
  my $fc = shift;
  GENERAL::requireArgs($self, $a, $xref, $yref, $zref, $lb, $ub, $fc);
  my %prop = @_;
  GENERAL::assert($lb <= $ub, "Lower bound not <= upper bound: '$lb' and '$ub'");

  my %r;
  push(@{$r{"atoms"}}, $a);
  push(@{$r{"atoms_vmd"}}, NAMD::toVMDsel($a));
  $r{"xref"} = $xref;
  $r{"yref"} = $yref;
  $r{"zref"} = $zref;
  $r{"LB"} = $lb;
  $r{"UB"} = $ub;
  $r{"FC"} = $fc;
  $r{"type"} = "INPLACEDIST";
  $r{margin} = 0;
  foreach my $k (keys(%prop)) {
    $r{$k} = $prop{$k};
  }
  push(@{$self->{restraints}->{INPLACEDIST}}, \%r);
  push(@{$self->{restraints_in_order}}, \%r);
}

=head2

 Title   :  getRestraints
 Usage   :  my $Cdef = $namd->getRestraints();
 Function:  Returns a reference to an array of imposed restraints, in the order they were applied
 Returns :  A reference to an array of imposed restraints, in the order they were applied
 Args    :

=cut

sub getRestraints {
  my $self = shift;

  if (!defined($self->{restraints_in_order})) {
    my @tmp; $self->{restraints_in_order} = \@tmp;
  }
  return $self->{restraints_in_order};
}

=head2

 Title   :  writeRestraints
 Usage   :  $namd->writeRestraints();
 Function:  In any custom restraints were defined, write them to the control file
 Returns :  Nothing
 Args    :
=cut

sub writeRestraints {
  my $self = shift;

  return if (!defined($self->{restraints}));

  $self->send("tclForces on\n");
  $self->send("tclForcesScript {\n");

  if ((defined($self->{restraints}->{DIHE})) && (scalar(@{$self->{restraints}->{DIHE}}) > 0)) {
    # define a proper mod function, which is convenient for angles
    $self->send("  proc mod {a b} {\n");
    $self->send('    return [expr $a - floor($a*1.0/$b)*$b]'."\n");
    $self->send("  }\n");

    # create lists of 1st-4th atoms in each dihedral, lists of upper/lower bounds, and a list of force constants
    for (my $i = 1; $i <= 4; $i++) {
      $self->send("  set dha$i"."L [concat");
      foreach my $dhr (@{$self->{restraints}->{DIHE}}) {
        $self->send(" [atomid " . ($dhr->{atoms}->[$i-1]) . "]");
      }
      $self->send("]\n");
    }
    $self->send("  set dhlbL {");
    foreach my $r (@{$self->{restraints}->{DIHE}}) { $self->send(sprintf(" %f", GENERAL::angleDiff($r->{LB}, -$r->{margin}))); }
    $self->send("}\n");
    $self->send("  set dhubL {");
    foreach my $r (@{$self->{restraints}->{DIHE}}) { $self->send(sprintf(" %f", GENERAL::angleDiff($r->{UB}, $r->{margin}))); }
    $self->send("}\n");
    $self->send("  set dhKL {");
    foreach my $r (@{$self->{restraints}->{DIHE}}) { $self->send(" $r->{FC}"); }
    $self->send("}\n");

    # add atoms to coordinate list for retreival in calcforces
    $self->send('  for {set i 0} { $i < [llength $dha1L]} { incr i} {'."\n");
    $self->send('    addatom [lindex $dha1L $i]'."\n");
    $self->send('    addatom [lindex $dha2L $i]'."\n");
    $self->send('    addatom [lindex $dha3L $i]'."\n");
    $self->send('    addatom [lindex $dha4L $i]'."\n");
    $self->send('  }'."\n");
  }
  if ((defined($self->{restraints}->{ANGL})) && (scalar(@{$self->{restraints}->{ANGL}}) > 0)) {

    # create lists of 1st-3rd atoms in each angle, lists of upper/lower bounds, and a list of force constants
    for (my $i = 1; $i <= 3; $i++) {
      $self->send("  set ana$i"."L [concat");
      foreach my $dar (@{$self->{restraints}->{ANGL}}) {
        $self->send(" [atomid " . ($dar->{atoms}->[$i-1]) . "]");
      }
      $self->send("]\n");
    }
    $self->send("  set anlbL {");
    foreach my $r (@{$self->{restraints}->{ANGL}}) { $self->send(sprintf(" %f", $r->{LB} + $r->{margin})); } # don't use mod in the difference, because regular angles only go from 0 to pi
    $self->send("}\n");
    $self->send("  set anubL {");
    foreach my $r (@{$self->{restraints}->{ANGL}}) { $self->send(sprintf(" %f", $r->{UB} - $r->{margin})); }
    $self->send("}\n");
    $self->send("  set anKL {");
    foreach my $r (@{$self->{restraints}->{ANGL}}) { $self->send(" $r->{FC}"); }
    $self->send("}\n");

    # add atoms to coordinate list for retreival in calcforces
    $self->send('  for {set i 0} { $i < [llength $ana1L]} { incr i} {'."\n");
    $self->send('    addatom [lindex $ana1L $i]'."\n");
    $self->send('    addatom [lindex $ana2L $i]'."\n");
    $self->send('    addatom [lindex $ana3L $i]'."\n");
    $self->send('  }'."\n");
  }
  if ((defined($self->{restraints}->{DIST})) && (scalar(@{$self->{restraints}->{DIST}}) > 0)) {
    # create lists of 1st-2nd atoms in each distance, lists of upper/lower bounds, and a list of force constants
    for (my $i = 1; $i <= 2; $i++) {
      $self->send("  set dia$i"."L [concat");
      foreach my $dir (@{$self->{restraints}->{DIST}}) {
        $self->send(" [atomid " . ($dir->{atoms}->[$i-1]) . "]");
      }
      $self->send("]\n");
    }
    $self->send("  set dilbL {");
    foreach my $r (@{$self->{restraints}->{DIST}}) { $self->send(sprintf(" %f", $r->{LB} + $r->{margin})); }
    $self->send("}\n");
    $self->send("  set diubL {");
    foreach my $r (@{$self->{restraints}->{DIST}}) { $self->send(sprintf(" %f", $r->{UB} - $r->{margin})); }
    $self->send("}\n");
    $self->send("  set diKL {");
    foreach my $r (@{$self->{restraints}->{DIST}}) { $self->send(" $r->{FC}"); }
    $self->send("}\n");

    # add atoms to coordinate list for retreival in calcforces
    $self->send('  for {set i 0} { $i < [llength $dia1L]} { incr i} {'."\n");
    $self->send('    addatom [lindex $dia1L $i]'."\n");
    $self->send('    addatom [lindex $dia2L $i]'."\n");
    $self->send('  }'."\n");
  }
  if ((defined($self->{restraints}->{INPLACEDIST})) && (scalar(@{$self->{restraints}->{INPLACEDIST}}) > 0)) {
    # define a distance function
    $self->send("  proc veclen {v1} {\n");
    $self->send('    foreach {x1 y1 z1} $v1 { break }'."\n");
    $self->send('    return [expr sqrt($x1*$x1 + $y1*$y1 + $z1*$z1)]'."\n");
    $self->send("  }\n");

    # create lists of 1st-2nd atoms in each distance, lists of upper/lower bounds, and a list of force constants
    $self->send("  set idL [concat");
    foreach my $dir (@{$self->{restraints}->{INPLACEDIST}}) {
      $self->send(" [atomid " . ($dir->{atoms}->[0]) . "]");
    }
    $self->send("]\n");
    $self->send("  set idlbL {");
    foreach my $r (@{$self->{restraints}->{INPLACEDIST}}) { $self->send(sprintf(" %f", $r->{LB} + $r->{margin})); }
    $self->send("}\n");
    $self->send("  set idubL {");
    foreach my $r (@{$self->{restraints}->{INPLACEDIST}}) { $self->send(sprintf(" %f", $r->{UB} - $r->{margin})); }
    $self->send("}\n");
    $self->send("  set idKL {");
    foreach my $r (@{$self->{restraints}->{INPLACEDIST}}) { $self->send(" $r->{FC}"); }
    $self->send("}\n");
    $self->send("  set idRef {");
    foreach my $r (@{$self->{restraints}->{INPLACEDIST}}) { $self->send(" {$r->{xref} $r->{yref} $r->{zref}}"); }
    $self->send(" }\n");

    # add atoms to coordinate list for retreival in calcforces
    $self->send('  for {set i 0} { $i < [llength $idL]} { incr i} {'."\n");
    $self->send('    addatom [lindex $idL $i]'."\n");
    $self->send('  }'."\n");
  }
  # write calcforces
  $self->send('  proc calcforces {} {'."\n");
  $self->send("    loadcoords p\n");
  if ((defined($self->{restraints}->{DIHE})) && (scalar(@{$self->{restraints}->{DIHE}}) > 0)) {
    $self->send("    global dha1L dha2L dha3L dha4L dhubL dhlbL dhKL\n");
    $self->send('    for {set i 0} { $i < [llength $dha1L]} { incr i} {'."\n");
    for (my $k = 1; $k <= 4; $k++) { $self->send("      set aid$k [lindex \$dha$k"."L \$i]\n"); }
    $self->send('      set ub [lindex $dhubL $i]'."\n");
    $self->send('      set lb [lindex $dhlbL $i]'."\n");
    $self->send('      set phi [getdihedral $p($aid1) $p($aid2) $p($aid3) $p($aid4)]'."\n"); # current value of dihedral
    $self->send('      set dw [mod [expr [mod $ub 360] - [mod $lb 360]] 360]'."\n"); # positive (counter-clockwise) distance from LB to UB (width of desired region)
    $self->send('      set dL [mod [expr [mod $phi 360] - [mod $lb 360]] 360]'."\n"); # counter-clockwise distance from LB to current dihedral value
    $self->send('      set dU [mod [expr [mod $ub 360] - [mod $phi 360]] 360]'."\n"); # counter-clockwise distance from current dihedral value to UB
    $self->send('      if {($dL > $dw) || ($dU > $dw)} {'."\n"); # both distances have to be less than distance from LB to UB for the dihedral to be within desired region
    $self->send('        if {[expr {$dL > 180}]} {'."\n");
    $self->send('          set dL [expr $dL - 360]'."\n");
    $self->send('        }'."\n");
    $self->send('        if {[expr {$dU > 180}]} {'."\n");
    $self->send('          set dU [expr $dU - 360]'."\n");
    $self->send('        }'."\n");
    $self->send('        set d $dL'."\n");
    $self->send('        if {[expr abs($dU) < abs($dL)]} {'."\n");
    $self->send('          set d [expr -$dU]'."\n"); # negative, because the difference between phi and lower bound was in the phi - LB order, whereas for upper bound it was UB - phi
    $self->send('        }'."\n");
    $self->send('        set k [lindex $dhKL $i]'."\n");
    $self->send('        addenergy [expr $k*$d*$d/2]'."\n"); # add this constraining energy to 'MISC' in the energy output
    $self->send('        set force [expr -$k*$d]'."\n"); # calculate the 'force' along the dihedral according to the constraint
    $self->send('        foreach {g1 g2 g3 g4} [dihedralgrad $p($aid1) $p($aid2) $p($aid3) $p($aid4)] {}'."\n"); # calculate the gradients
    for (my $k = 1; $k <= 4; $k++) { $self->send("        addforce \$aid$k [vecscale \$g$k \$force]\n"); }
    $self->send('      }'."\n");
    $self->send('    }'."\n");
  }
  if ((defined($self->{restraints}->{ANGL})) && (scalar(@{$self->{restraints}->{ANGL}}) > 0)) {
    $self->send("    global ana1L ana2L ana3L anubL anlbL anKL\n");
    $self->send('    for {set i 0} { $i < [llength $ana1L]} { incr i} {'."\n");
    for (my $k = 1; $k <= 3; $k++) { $self->send("      set aid$k [lindex \$ana$k"."L \$i]\n"); }
    $self->send('      set ub [lindex $anubL $i]'."\n");
    $self->send('      set lb [lindex $anlbL $i]'."\n");
    $self->send('      set angl [getangle $p($aid1) $p($aid2) $p($aid3)]'."\n"); # current value of dihedral

    $self->send('      set delta 0'."\n");
    $self->send('      if {($angl < $lb)} {'."\n");
    $self->send('        set delta [expr ($angl - $lb)]'."\n");
    $self->send('      } elseif {($angl > $ub)} {'."\n");
    $self->send('        set delta [expr ($angl - $ub)]'."\n");
    $self->send('      }'."\n");
    $self->send('      if {($delta > 0)} {'."\n");
    $self->send('        set k [lindex $anKL $i]'."\n");
    $self->send('        addenergy [expr $k*$delta*$delta/2]'."\n"); # (optional) Add this constraining energy to "MISC" in the energy output
    $self->send('        set force [expr -$k*$delta]'."\n"); # Calculate the "force" along the bond according to the constraint
    $self->send('        foreach {g1 g2 g3} [anglegrad $p($aid1) $p($aid2) $p($aid3)] {}'."\n"); # calculate the gradients
    for (my $k = 1; $k <= 3; $k++) { $self->send("        addforce \$aid$k [vecscale \$g$k \$force]\n"); }
    $self->send('      }'."\n");
    $self->send('    }'."\n");
  }
  if ((defined($self->{restraints}->{DIST})) && (scalar(@{$self->{restraints}->{DIST}}) > 0)) {
    $self->send("    global dia1L dia2L diubL dilbL diKL\n");
    $self->send('    for {set i 0} { $i < [llength $dia1L]} { incr i} {'."\n");
    for (my $k = 1; $k <= 2; $k++) { $self->send("      set aid$k [lindex \$dia$k"."L \$i]\n"); }
    $self->send('      set ub [lindex $diubL $i]'."\n");
    $self->send('      set lb [lindex $dilbL $i]'."\n");
    $self->send('      set dist [getbond $p($aid1) $p($aid2)]'."\n"); # current value of distance
    $self->send('      set delta 0'."\n");
    $self->send('      if {($dist < $lb)} {'."\n");
    $self->send('        set delta [expr ($dist - $lb)]'."\n");
    $self->send('      } elseif {($dist > $ub)} {'."\n");
    $self->send('        set delta [expr ($dist - $ub)]'."\n");
    $self->send('      }'."\n");
    $self->send('      if {($delta > 0)} {'."\n");
    $self->send('        set k [lindex $diKL $i]'."\n");
    $self->send('        addenergy [expr $k*$delta*$delta/2]'."\n"); # (optional) Add this constraining energy to "MISC" in the energy output
    $self->send('        set force [expr -$k*$delta]'."\n"); # Calculate the "force" along the bond according to the constraint
    $self->send('        set a1grad [vecscale [vecsub $p($aid1) $p($aid2)] [expr 1/$dist]]'."\n"); # Calculate gradients
    $self->send('        set a2grad [vecscale $a1grad -1]'."\n");
    $self->send('        addforce $aid1 [vecscale $a1grad $force]'."\n"); # The force to be applied on each atom is proportional to its corresponding gradient
    $self->send('        addforce $aid2 [vecscale $a2grad $force]'."\n");
    $self->send('      }'."\n");
    $self->send('    }'."\n");
  }
  if ((defined($self->{restraints}->{INPLACEDIST})) && (scalar(@{$self->{restraints}->{INPLACEDIST}}) > 0)) {
    $self->send("    global idL idubL idlbL idKL idRef\n");
    $self->send('    for {set i 0} { $i < [llength $idL]} { incr i} {'."\n");
    $self->send('      set aid [lindex $idL $i]'."\n");
    $self->send('      set ub [lindex $idubL $i]'."\n");
    $self->send('      set lb [lindex $idlbL $i]'."\n");
    $self->send('      set ref [lindex $idRef $i]'."\n");
    $self->send('      set dist [veclen [vecsub $p($aid) $ref]]'."\n"); # current value of distance
    $self->send('      set delta 0'."\n");
    $self->send('      if {($dist < $lb)} {'."\n");
    $self->send('        set delta [expr ($dist - $lb)]'."\n");
    $self->send('      } elseif {($dist > $ub)} {'."\n");
    $self->send('        set delta [expr ($dist - $ub)]'."\n");
    $self->send('      }'."\n");
    $self->send('      if {($delta > 0)} {'."\n");
    $self->send('        set k [lindex $idKL $i]'."\n");
    $self->send('        addenergy [expr $k*$delta*$delta/2]'."\n"); # (optional) Add this constraining energy to "MISC" in the energy output
    $self->send('        set force [expr -$k*$delta]'."\n"); # Calculate the "force" along the bond according to the constraint
    $self->send('        set a1grad [vecscale [vecsub $p($aid) $ref] [expr 1/$dist]]'."\n"); # Calculate gradients
    $self->send('        set a2grad [vecscale $a1grad -1]'."\n");
    $self->send('        addforce $aid [vecscale $a1grad $force]'."\n"); # The force to be applied on each atom is proportional to its corresponding gradient
    $self->send('      }'."\n");
    $self->send('    }'."\n");
  }
  $self->send('  }'."\n"); # end of calcforces
  $self->send("}\n"); # end of tclForces
}

=head2

 Title   :  createPSF
 Usage   :  NAMD::createPSF("input.pdb", "topology.file", "output.pdb", "output.psf");
            NAMD::createPSF("input.pdb", "topology.file", "output.pdb", "output.psf", "first NONE; last NONE; auto angles");
 Function:  Generates a PSF for the structure
 Returns :  Nothing
 Args    :  1. Input PDB file
            2. Topology file
            3. Output PDB file
            4. Output PSF file
            5. Additional options are interpreted as a hash:
              'genopts'   -   optional: PSF generation options (e.g. "first NONE; last NONE; auto angles"). Array referrence, one entry per chain.
              'vmd_bin'   -   optional: bath to VMD binary to use
              'patches'   -   optional: patches or other commands, (e.g. 'patch DISU BPTI:5 BPTI:55'). Array reference, one entry per chain.

=cut

sub createPSF {
  my $ipdbf = shift;
  my $topf = shift;
  my $opdbf = shift;
  my $opsff = shift;
  GENERAL::requireArgs($ipdbf, $topf, $opdbf, $opsff);
  my %opts = @_; # additional options
  my $psfgopts = $opts{genopts};
  my $vmd_bin = $opts{vmd_bin}; $vmd_bin = "/home/grigoryanlab/local/bin/vmd" if (!defined($vmd_bin));
  my $patches = $opts{patches};

  my $pdb = PDB::new($ipdbf);
  my $tmppgn = "_$$\_tmp_pdb_psf.pgn"; my @rmfiles = ($tmppgn);
  my $amb = !(GENERAL::Trim(`grep "AMBER" $topf | wc -l`) eq "0");

  # first split structure into chains and write separate PSF and PDB files
  my (@cpdbf, @cpsff);
  for (my $ci = 0; $ci < scalar(@{$pdb->{chain}}); $ci++) {
    my $chain = $pdb->{chain}->[$ci];
    my $cpdbf = GENERAL::GetBase($opdbf) . "_tmp_" . $chain->{id} . ".pdb";
    my $cpsff = GENERAL::GetBase($opdbf) . "_tmp_" . $chain->{id} . ".psf";
    push(@cpdbf, $cpdbf); push(@cpsff, $cpsff); push(@rmfiles, $cpdbf); push(@rmfiles, $cpsff);
    $pdb->writePDB($cpdbf, "", $chain->{id});
    my $ofh = GENERAL::GetOutFH($tmppgn);
    $ofh->print("package require psfgen\ntopology $topf\n");
    $ofh->print("\nalias residue HIS HSD\nalias atom ILE CD1 CD\n") if ($amb == 0);
    $ofh->print("\nalias residue HIS HID\n") if ($amb == 1);
    $ofh->print("\nalias residue DA ADE\nalias residue DC CYT\nalias residue DG GUA\nalias residue DT THY\n");
    my $chopts = "";
    if (defined($psfgopts)) {
      if (scalar(@$psfgopts) == 1) {
        $chopts = "$psfgopts->[0];"
      } elsif (scalar(@$psfgopts) > $ci) {
        $chopts = "$psfgopts->[$ci];"
      }
    }
    $ofh->printf("segment $chain->{id} {$chopts pdb $cpdbf}\ncoordpdb $cpdbf $chain->{id}\n");
    $ofh->printf("$patches->[$ci]\n") if (defined($patches));
    $ofh->printf("guesscoord\nwritepdb $cpdbf\nwritepsf $cpsff\nexit\n");
    close($ofh);
    NAMD::runVMD($tmppgn, "bin", $vmd_bin);
  }

  # next combine the individual PSFs and PDBs into one
  my $ofh = GENERAL::GetOutFH($tmppgn);
  $ofh->print("package require psfgen\ntopology $topf\n");
  for (my $i = 0; $i < scalar(@cpdbf); $i++) {
    $ofh->print("readpsf $cpsff[$i]\ncoordpdb $cpdbf[$i]\n");
  }
  $ofh->print("writepdb $opdbf\nwritepsf $opsff\nexit\n");
  close($ofh);
  NAMD::runVMD($tmppgn, "bin", $vmd_bin);

  # clean up
  foreach my $rmfile (@rmfiles) {
    GENERAL::crm($rmfile) if (-e $rmfile);
  }
}


=head2

 Title   :  waterBox
 Usage   :  NAMD::waterBox("input.pdb", "input.psf", 5.0, "output.pdb", "output.psf");
            NAMD::waterBox("input.pdb", "input.psf", '-x 5 -y 5 -z 0 +x 5 +y 5 +z 0', "output.pdb", "output.psf");
 Function:  Solvates the given molecule with a water box, first using Helmut Grubmüller solvate method to place water molecules around the surface of the solute
            and then using VMD to fill in the rest of the cube
 Returns :  Structure reporting information about the solvated system
 Args    :  1. Input PDB file
            2. Input PSF file
            3. Padding - either a single number, in which case this many Angstroms will be padded from each side, or a custom string like '-x 5 -y 5 -z 0 +x 5 +y 5 +z 0'
               to specify different padding in different dimensions.
            3. Output PDB file
            4. Output PSF file
            5. Topology file, needed for creating a PSF for the solvated file after using the Grubmüller package
            6. Additional 'parameter', 'value' pairs. Current possibilities are:
               'rotate'   -   optional: 'yes' or 'no' specify whether to allow VMD to optimally rotate the molecule to minimize the volume of bounding box or no
               'ngauss'   -   optional: the number of gaussians used to define solvent surface in Grubmüller's package (default: 2)

=cut

sub waterBox {
  my $pdbf = shift;
  my $psff = shift;
  my $pad = shift;
  my $opdbf = shift;
  my $opsff = shift;
  my $topf = shift;
  my %opts = @_;
  GENERAL::requireArgs($pdbf, $psff, $pad, $opdbf, $opsff, $topf);
  my $tmpb = "_$$\_" . GENERAL::GetMachine();
  my $tpdbf = "$tmpb.pdb";
  my $tpsff = "$tmpb.psf";
  my $tspdbf = "$tmpb\_solv.pdb";
  my $tspsff = "$tmpb\_solv.psf";
  my $tmpof = "$tmpb.out";

  # first solvate by VMD to figure out best rotation to minimize volume, and save just the protein
  unless (defined($opts{rotate}) && ($opts{rotate} eq "no")) {
    my $S = waterBoxVMD($pdbf, $psff, $pad, $tpdbf, $tpsff, %opts);
    my $pdb = PDB::new($pdbf);
    my $tpdb = PDB::new($tpdbf);
    $tpdb->writePDB($tpdbf, "", join("", @{$pdb->getChainList()}));
  } else {
    GENERAL::csystem("cp $pdbf $tpdbf"); # for Grubmüller's solvate package, the extension must be .pdb
  }

  # solvate with Helmut Grubmüller's package to get a close ring around the molecule (and internal waters, if appropriate)
  my $ngauss = 2;
  $ngauss = $opts{ngauss} if (defined($opts{ngauss}));
  GENERAL::csystem("$BIN_DEF/solvate -t 5 -n $ngauss " . GENERAL::GetBase($tpdbf) . " " . GENERAL::GetBase($tspdbf) . " &> $tmpof");
  GENERAL::assert(`grep "No errors" $tmpof | wc -l` ne 0, "Error running 'solvate', see output file $tmpof");

  # create PSF for the solvated PDB
  my $nnw = scalar(@{(PDB::new($pdbf))->{chain}}); # number of original (non-water) chains
  my $nw = scalar(@{(PDB::new($tspdbf))->{chain}}) - $nnw; # number of added (water) chains
  my @psfopts = (("") x $nnw,  ("auto none") x $nw);
  NAMD::createPSF($tspdbf, $topf, $tspdbf, $tspsff, 'genopts', \@psfopts);

  # now solvate with VMD, without rotation, to get a wide box. This box will have too many waters, since we've already
  # created a ring of 5.0 Angstroms, so we will remove excess waters later
  $opts{rotate} = "no";
  my $S = waterBoxVMD($tspdbf, $tspsff, $pad, $tspdbf, $tspsff, %opts);

  # pad array
  my @pad;
  if (GENERAL::isNumeric($pad)) { @pad = ($pad) x 6; }
  else {
    my %pad = split(" ", GENERAL::Trim($pad));
    GENERAL::assert(defined($pad{"-x"}) && defined($pad{"-y"}) && defined($pad{"-z"}) && defined($pad{"+x"}) && defined($pad{"+y"}) && defined($pad{"+z"}), "could not regocnize pad string '$pad'");
    @pad = ($pad{"-x"}, $pad{"-y"}, $pad{"-z"}, $pad{"+x"}, $pad{"+y"}, $pad{"+z"});
  }

  # VMD script to remove excess water
  my $tmptcl = "$tmpb.tcl";
  my $ofh = GENERAL::GetOutFH($tmptcl);
  $ofh->printf("
  package require psfgen
  # load PSF/PDB into psfgen and VMD
  resetpsf
  readpsf $tspsff
  coordpdb $tspdbf
  mol load psf $tspsff pdb $tspdbf
  set mm [measure minmax [atomselect top \"not water\"]]
  set selDel [atomselect top \"((x < [lindex [lindex \$mm 0] 0] - $pad[0]) or (y < [lindex [lindex \$mm 0] 1] - $pad[1]) or (z < [lindex [lindex \$mm 0] 2] - $pad[2]) or ".
                               "(x > [lindex [lindex \$mm 1] 0] + $pad[3]) or (y > [lindex [lindex \$mm 1] 1] + $pad[4]) or (z > [lindex [lindex \$mm 1] 2] + $pad[5])) and name OH2\"]
  puts  \"will delete [\$selDel num] waters outside of bounding box\"
  foreach segid [\$selDel get segid] resid [\$selDel get resid] {
      delatom \$segid \$resid
  }
  writepsf $opsff
  writepdb $opdbf
  mol delete top
  mol load psf $opsff pdb $opdbf
  set mm [measure minmax [atomselect top all]]
  set cen [measure center [atomselect top all]]
  puts \"CENTER OF MASS IS AT: \$cen\";
  puts \"MINMAX IS \$mm\";
  exit
  ");
  close($ofh);
  NAMD::runVMD($tmptcl, "output", $tmpof, "keep_output", 1);

  # get information about water box
  my %S; $S{type} = "BOX";
  my $l = `grep 'CENTER OF MASS IS AT:' $tmpof`; chomp($l);
  if ($l eq "") { GENERAL::error("Could not parse solvation output to get box center! Check file $tmpof..."); }
  my @tmp = split(" ", $l);
  if ((scalar(@tmp) != 8) || (!GENERAL::isNumeric($tmp[5])) || (!GENERAL::isNumeric($tmp[6])) || (!GENERAL::isNumeric($tmp[7]))) {
    GENERAL::error("Could not parse solvation output to get sphere center! Check file $tmpof...");
  }
  $S{cx} = $tmp[5]; $S{cy} = $tmp[6]; $S{cz} = $tmp[7]; # center X, Y, Z

  $l = `grep 'MINMAX IS ' $tmpof`; chomp($l);
  if ($l eq "") { GENERAL::error("Could not parse solvation output to get box MINMAX! Check file $tmpof..."); }
  $l =~ s/[\{\}]//g;
  @tmp = split(" ", $l);
  if ((scalar(@tmp) != 8) || !(GENERAL::isNumeric($tmp[2]) && GENERAL::isNumeric($tmp[3]) && GENERAL::isNumeric($tmp[4]) &&
                              GENERAL::isNumeric($tmp[5]) && GENERAL::isNumeric($tmp[6]) && GENERAL::isNumeric($tmp[7]))) {
    GENERAL::error("Could not parse solvation output to get sphere center! Check file $tmpof...");
  }
  $S{xsize} = abs($tmp[2]-$tmp[5]); $S{ysize} = abs($tmp[3]-$tmp[6]); $S{zsize} = abs($tmp[4]-$tmp[7]);

  # clean up
  GENERAL::crm($tpdbf, $tpsff, $tmptcl, $tmpof, $tspdbf, $tspsff);

  return \%S;
}

=head2

 Title   :  waterBoxVMD
 Usage   :  NAMD::waterBoxVMD("input.pdb", "input.psf", 5.0, "output.pdb", "output.psf");
            NAMD::waterBoxVMD("input.pdb", "input.psf", '-x 5 -y 5 -z 0 +x 5 +y 5 +z 0', "output.pdb", "output.psf");
 Function:  Solvates the given molecule with a water box, using the solvate module of VMD
 Returns :  Structure reporting information about the solvated system
 Args    :  1. Input PDB file
            2. Input PSF file
            3. Padding - either a single number, in which case this many Angstroms will be padded from each side, or a custom string like '-x 5 -y 5 -z 0 +x 5 +y 5 +z 0'
               to specify different padding in different dimensions.
            3. Output PDB file
            4. Output PSF file

=cut

sub waterBoxVMD {
  my $pdb = shift;
  my $psf = shift;
  my $pad = shift;
  my $opdb = shift;
  my $opsf = shift;
  my %opts = @_;
  GENERAL::requireArgs($pdb, $psf, $pad, $opdb, $opsf);
  $pad = "-t $pad" if (GENERAL::isNumeric($pad));
  my $rotate = "-rotate"; $rotate = "" if (defined($opts{"rotate"}) && ($opts{"rotate"} eq "no"));

  # create solvation script
  my $tmpn = "_$$\_" . GENERAL::GetMachine(); my $tmptcl = "$tmpn\_box.ctl"; my $box = "$tmpn\_box"; my $tmpof = "$tmpn.out";
  my $ofh = GENERAL::GetOutFH($tmptcl);
  $ofh->printf("set box $box\npackage require solvate\n");
  $ofh->printf("solvate $psf $pdb $pad -o \$box $rotate\n");
  $ofh->printf('mol load psf ${box}.psf pdb ${box}.pdb' . "\n");
  $ofh->printf('set everyone [atomselect top all]'."\n");
  $ofh->printf('set mm [measure minmax $everyone]' ."\n");
  $ofh->printf('set cen [measure center $everyone]'."\n");
  $ofh->printf('puts "CENTER OF MASS IS AT: $cen"'."\n");
  $ofh->printf('puts "MINMAX IS $mm"'."\n\n");
  $ofh->printf("file rename -force \${box}.pdb $opdb\n");
  $ofh->printf("file rename -force \${box}.psf $opsf\n");
  $ofh->printf("exit\n");
  close($ofh);

  # run solvation script
  NAMD::runVMD($tmptcl, "output", "$tmpn.out", "keep_output", 1);

  # get information about water sphere
  my %S; $S{type} = "BOX";
  my $l = `grep 'CENTER OF MASS IS AT:' $tmpof`; chomp($l);
  if ($l eq "") { GENERAL::error("Could not parse solvation output to get box center! Check file $tmpof..."); }
  my @tmp = split(" ", $l);
  if ((scalar(@tmp) != 8) || (!GENERAL::isNumeric($tmp[5])) || (!GENERAL::isNumeric($tmp[6])) || (!GENERAL::isNumeric($tmp[7]))) {
    GENERAL::error("Could not parse solvation output to get sphere center! Check file $tmpof...");
  }
  $S{cx} = $tmp[5]; $S{cy} = $tmp[6]; $S{cz} = $tmp[7]; # center X, Y, Z

  $l = `grep 'MINMAX IS ' $tmpof`; chomp($l);
  if ($l eq "") { GENERAL::error("Could not parse solvation output to get box MINMAX! Check file $tmpof..."); }
  $l =~ s/[\{\}]//g;
  @tmp = split(" ", $l);
  if ((scalar(@tmp) != 8) || !(GENERAL::isNumeric($tmp[2]) && GENERAL::isNumeric($tmp[3]) && GENERAL::isNumeric($tmp[4]) &&
                              GENERAL::isNumeric($tmp[5]) && GENERAL::isNumeric($tmp[6]) && GENERAL::isNumeric($tmp[7]))) {
    GENERAL::error("Could not parse solvation output to get sphere center! Check file $tmpof...");
  }
  $S{xsize} = abs($tmp[2]-$tmp[5]); $S{ysize} = abs($tmp[3]-$tmp[6]); $S{zsize} = abs($tmp[4]-$tmp[7]);

  GENERAL::crm($tmptcl, $tmpof, "$box.log"); # temp files left by the solvate command of vmd
  return \%S;
}


=head2

 Title   :  addIons
 Usage   :  NAMD::autoIonize("input.pdb", "input.psf", "output_neutralized", "neutralize");
 Function:  Adds common salt ions to the structure.
 Returns :
 Args    :  1. Input PDB file
            2. Input PSF file
            3. Prefix for output files (files will be $output.pdb and $output.psf)
            4. What to do: currently either 'neutralize' to ballance out charge with NaCl or
               just a direct string of options to pass to the autoionize plugin of vmd

=cut

sub addIons {
  my $pdbf = shift;
  my $psff = shift;
  my $obase = shift;
  my $opts = shift;
  GENERAL::requireArgs($pdbf, $psff, $obase, $opts);
  $opts = "-neutralize" if (lc($opts) eq "neutralize");

  my $tmptcl = "_autoionize.$$.ctl";
  my $ofh = GENERAL::GetOutFH($tmptcl);
  $ofh->printf("package require autoionize\nautoionize -psf $psff -pdb $pdbf -o $obase $opts\n");
  close($ofh);
  NAMD::runVMD($tmptcl);
  GENERAL::crm($tmptcl);
}

=head2

 Title   :  deleteAtoms
 Usage   :  NAMD::deleteAtoms("input.pdb", "input.psf", "output.pdb", "output.psf", "atomselect top \"name OH2 and not within 10 of protein\"");

 Function:  Deletes a specific selection of atoms from the PDB and PSF and writes new PDB and PSF files.
 Returns :  Nothing
 Args    :  1. Input PDB file
            2. Input PSF file
            3. Output PDB file
            4. Output PSF file
            5. A string representing a VMD atom selection

=cut

sub deleteAtoms {
  my $pdb = shift;
  my $psf = shift;
  my $opdb = shift;
  my $opsf = shift;
  my $sel = shift;
  GENERAL::requireArgs($pdb, $psf, $opdb, $opsf, $sel);

  # create delete script
  my $tmpn = "_$$\_" . GENERAL::GetMachine(); my $tmptcl = "$tmpn\_del.ctl";
  my $ofh = GENERAL::GetOutFH($tmptcl);
  $ofh->print("package require psfgen\n");
  $ofh->print("readpsf $psf\ncoordpdb $pdb\n");
  $ofh->printf("mol load psf $psf pdb $pdb\n");
  $ofh->printf("set toDelete [$sel]\n");
  $ofh->printf("foreach segid [\$toDelete get segid] resid [\$toDelete get resid] name [\$toDelete get name] {\n");
  $ofh->printf("  delatom \$segid \$resid \$name\n");
  $ofh->printf("}\n");
  $ofh->printf("writepsf $opsf\n");
  $ofh->printf("writepdb $opdb\n");
  $ofh->printf("exit\n");
  close($ofh);

  # run delete script
  NAMD::runVMD($tmptcl, "output", "$tmpn.out", "keep_output", 1);
  GENERAL::crm($tmptcl, "$tmpn.out");
}


=head2

 Title   :  combineStructs
 Usage   :  NAMD::combineStructs("input1.pdb", "input1.psf", "input2.pdb", "input2.psf", ..., "output.pdb", "output.psf");
 Function:  Combines two or more psf/pdb structures into one big one and writes it out.
 Returns :  Nothing
 Args    :  1. Input PDB file of 1st structure
            2. Input PSF file of 1st structure
            3. Input PDB file of 2nd structure
            4. Input PSF file of 2nd structure
            ...
            2*n+1. Output PDB file
            2*n+2. Output PSF file

=cut

sub combineStructs {
  GENERAL::assert(scalar(@_) % 2 == 0, "Even number of arguments expected");
  GENERAL::assert(scalar(@_) >= 4, "At least four arguments expected");
  my $opsf = pop;
  my $opdb = pop;

  # create delete script
  my $tmpn = "_$$\_" . GENERAL::GetMachine(); my $tmptcl = "$tmpn\_del.ctl";
  my $ofh = GENERAL::GetOutFH($tmptcl);
  $ofh->print("package require psfgen\n");
  for (my $i = 0; $i < scalar(@_); $i += 2) {
    $ofh->print("readpsf $_[$i+1]\ncoordpdb $_[$i]\n");
  }
  $ofh->printf("writepsf $opsf\n");
  $ofh->printf("writepdb $opdb\n");
  $ofh->printf("exit\n");
  close($ofh);

  # run delete script
  NAMD::runVMD($tmptcl, "output", "$tmpn.out", "keep_output", 1);
  GENERAL::crm($tmptcl, "$tmpn.out");
}

=head2

 Title   :  autoRestart
 Usage   :  $namd->autoRestart();
 Function:  Edits the restart section of the control file such that the simulation automatically restarts if rerun.
 Returns :  Nothing
 Args    :

=cut

sub autoRestart {
  my $self = shift;

  my $proc =
'proc get_first_ts { xscfile } {
  set fd [open $xscfile r]
  gets $fd
  gets $fd
  gets $fd line
  set ts [lindex $line 0]
  close $fd
  return $ts
}';
  $self->addProcedure("get_first_ts", $proc);

  my $autorestart =
'set newoutname $outname
while {1} {
  if { [file exists $newoutname.restart.coor] && [file exists $newoutname.restart.vel] && [file exists $newoutname.restart.xsc] } {
      set restart [expr $restart+1]
      set newoutname $outname-r$restart
      if {$restart == 1} {
        set oldoutname $outname
      } else {
        set oldoutname [concat $outname-r[expr $restart-1]]
      }
  } else { break; }
}

# set first timestep and initialize output name
set ftt 0
if {$restart} {
  set ftt [get_first_ts $oldoutname.restart.xsc]
  set outname $newoutname
  firsttimestep $ftt
}

# load velocities and coordinates, if restarting
if {$restart > 0} {
  binCoordinates      $oldoutname.restart.coor
  binVelocities       $oldoutname.restart.vel
  extendedSystem      $oldoutname.restart.xsc
}
';

  if ($self->isDefault("initialization", "temperature")) {
    $self->removeParameterValue("initialization", "temperature");
    $self->command("if {\$restart == 0} {\n  temperature \$temperature\n}", "initialization", "temperature");
  } else {
    GENERAL::error("Autorestart section needs to talk nicely to {initialization}{temperature}, and the latter has been modified from its default value!");
  }
  $self->command($autorestart, "restart");
}


=head2

 Title   :  runVMD
 Usage   :  NAMD::runVMD("input.vmd", "~/bin/vmd");
 Function:  Runs VMD and checks output for errors
 Returns :  Nothing
 Args    :  1. Input script file
            2. Binary

=cut

sub runVMD {
  my $script = shift;
  GENERAL::requireArgs($script);
  my %opts = @_;
  my ($vmd_bin, $vmdof);

  $vmdof = (defined($opts{"output"}) ? $opts{"output"} : "_$$\_" . GENERAL::GetMachine() . "\_temp.vmd.out");
  if (defined($opts{"bin"})) { $vmd_bin = $opts{"bin"}; }
  elsif ((defined($LOCAL_DEF)) && (! -d "$LOCAL_DEF/vmd_local/")) {
    # if local space defined, copy all of VMD once and always call it locally
    $vmd_bin = DEFINITIONS::getExec("vmd");
    my $vmds = GENERAL::file2array($vmd_bin); # vmd is just a C-shell script, which among other things sets the default VMD directory
    my $re = '^\s*set\s+defaultvmddir\s*=\s*(.+)$';
    my $line = GENERAL::findin_regexp($re, @$vmds);
    GENERAL::assert($line ne -1, "could not find line setting defaultvmddir in $vmd_bin");
    $vmds->[$line] =~ /$re/; my $ovmddir = $1;
    my $vmddir = "$LOCAL_DEF/vmd_local"; GENERAL::csystem("cp -r $ovmddir $vmddir");
    $vmds->[$line] = "set defaultvmddir=$vmddir";
    my $ofh = GENERAL::GetOutFH($vmd_bin); $ofh->print(join("\n", @$vmds) . "\n"); close($ofh);
  } else { $vmd_bin = DEFINITIONS::getExec("vmd"); }

  GENERAL::csystem("$vmd_bin -dispdev text -eofexit < $script >& $vmdof");
  my $ret = `grep ERROR $vmdof`; $ret = GENERAL::Trim($ret); GENERAL::error("vmd failed, see $vmdof for output...") if ($ret ne "");
  GENERAL::crm($vmdof) unless (defined($opts{"keep_output"}) && $opts{"keep_output"});
}


=head2

 Title   :  toVMDsel
 Usage   :  NAMD::toVMDsel("A 16 N");
 Function:  Converts a NAMD-style selection, e.g. "A 16 N" as used in atomid, into a VMD-style selection, e.g. segid ?? and resid ?? and name ??
 Returns :  VMD-style selection
 Args    :  1. NAMD-style selection of the format "<segname> <resid> <atomname>"

=cut

sub toVMDsel {
  my $sel = shift;
  my @sel = split(" ", $sel);
  GENERAL::assert(scalar(@sel) == 3, "did not recognize selection '$sel' - expected three fields");
  return "segid $sel[0] and resid $sel[1] and name $sel[2]";
}


=head2

 Title   :  analyzeRun
 Usage   :  $namd->analyzeRun("MISC", \@Cdef);
 Function:  Analyzes the given trajectory and returns various geometric variables, energies, etc.
 Returns :  A hash reference representing the sought variables, energies, etc.
 Args    :  1. NAMD structure
            2-x. A list of parameter name/parameter value pairs (e.g. 'ETERMS', 'MISC VDW'). The following parameter names are possible:
            CDEF    - array reference, definition of coordinates to fish out
            ETERMS  - a string, space separated list of additional terms, besides the total energy, to get for each snapshot
            TRAJ    - a string, space separated list of DCD files to load as the trajectory (will be loaded one at a time)
            FIRSTTS - integer, the first time step of interest (skip all output for time steps before this; e.g. energy output)
            FIRSTF  - integer, the first frame of interest of the trajectory

=cut

sub analyzeRun {
  my $self = shift;
  my %par = @_;

  # additional terms
  my $terms = $par{ETERMS}; # additional terms to save from each snapshot
  $terms = "POTENTIAL" . (defined($terms) ? " $terms" : "");
  my @terms = split(" ", GENERAL::Trim($terms));
  my $Cdef = $par{CDEF}; # definitions of phase space-defining coordinates
  $Cdef = $self->getRestraints() if (!defined($Cdef));

  # trajectory files
  my @trajf;
  if (defined($par{TRAJ})) { @trajf = split(" ", GENERAL::Trim($par{TRAJ})); }
  else {
    # default DCD naming, if not specified
    push(@trajf, $self->getParameterValue("variables", "set outname") . ".dcd");
    for (my $i = 1; $i < $self->{run}; $i++) {
      push(@trajf, $self->getParameterValue("variables", "set outname") . "-r$i.dcd");
    }
  }

  # get energy titles
  my %ret; # start composing the return hash
  if (defined($self->{files}->{outlog}) && (-e $self->{files}->{outlog})) {
    my $etitle = undef;
    my $ifh = GENERAL::GetInFH($self->{files}->{outlog});
    while (<$ifh>) { if (/^ETITLE/) { $etitle = GENERAL::Trim($_); last; } }
    close($ifh);
    GENERAL::assert(defined($etitle), "Could not find energy title in log file $self->{files}->{outlog}");
    my @etitle = split(" ", $etitle);
    shift @etitle; # remove ETITLE:

    # find indices of required terms
    my @terms_ind;
    foreach my $term (@terms) {
      my $ind = GENERAL::findin($term, @etitle);
      GENERAL::assert($ind >= 0, "Could not find term '$term' in energy title line '$etitle'");
      push(@terms_ind, $ind);
    }

    # get energies
    my @elines = `grep '^ENERGY:' $self->{files}->{outlog}`; @elines = GENERAL::Trim(@elines);
    my @ener; # final energy vector
    my @ts; # time step vector
    foreach my $eline (@elines) {
      my @eline = split(" ", $eline); shift @eline; # split and get rid of ENERGY:
      my $ts = $eline[0];
      next if (defined($par{FIRSTTS}) && ($ts < $par{FIRSTTS}));
      my $nen;
      if (scalar(@terms) == 1) {
        $nen = $eline[$terms_ind[0]];
      } else {
        my @picked;
        foreach my $ind (@terms_ind) { push(@picked, $eline[$ind]); }
        $nen = \@picked;
      }

      # sometimes, upon restarting, some time steps may repeat, so if they do, use the last values
      if ((scalar(@ts) > 0) && ($ts <= $ts[-1])) {
        my $ind = GENERAL::findin($ts, @ts);
        GENERAL::assert($ind >= 0, "Time step on line '$eline' is out of order, but time step '$ts' did not occur before");
        $ener[$ind] = $nen;
      } else {
        push(@ts, $ts);
        push(@ener, $nen);
      }
    }
    $ret{ener} = \@ener;
  }

  # portion of VMD script that will measure the individual coordinates
  if (defined($Cdef) && (scalar(@$Cdef) > 0)) {
    my $cref = "_ef.dat";
    my $measure = "";
    my $getinds = ""; my %ai; my $k = 1;


    foreach my $cdef (@$Cdef) {
      # first, get all necessary atom indices
      GENERAL::assert(scalar(@{$cdef->{atoms_vmd}}) == scalar(@{$cdef->{indices}}), "different number of VMD selection strings and indices in coordinate definition") if (defined($cdef->{indices}));
      for (my $i = 0; $i < scalar(@{$cdef->{atoms_vmd}}); $i++) {
        my $astr = $cdef->{atoms_vmd}->[$i];
        next if (defined($ai{$astr}));
        if (defined($cdef->{indices})) {
          $ai{$astr} = $cdef->{indices}->[$i];
        } else {
          $ai{$astr} = "i$k";
          $getinds .= "set $ai{$astr} [[atomselect top \"$astr\"] get index]\n";
          $ai{$astr} = "\$$ai{$astr}"; $k++;
        }
      }
      if (uc($cdef->{type}) =~ /^(DIHE|IMPR)$/) {
        $measure .= "\tputs \$outfile \"[measure dihed [list $ai{$cdef->{atoms_vmd}->[0]} $ai{$cdef->{atoms_vmd}->[1]} $ai{$cdef->{atoms_vmd}->[2]} $ai{$cdef->{atoms_vmd}->[3]}] frame \$i]\"\n";
      } elsif (uc($cdef->{type}) eq "DIST") {
        $measure .= "\tputs \$outfile \"[measure bond [list $ai{$cdef->{atoms_vmd}->[0]} $ai{$cdef->{atoms_vmd}->[1]}] frame \$i]\"\n";
      } elsif (uc($cdef->{type}) eq "INPLACEDIST") {
        # ATTENTION: can be made faster by pre-storing x, y, and z of all relevant atoms
        $measure .= "\tputs \$outfile [vecdist [list [[atomselect top \"$cdef->{atoms_vmd}->[0]\" frame \$i] get x] ".
                                                    "[[atomselect top \"$cdef->{atoms_vmd}->[0]\" frame \$i] get y] ".
                                                    "[[atomselect top \"$cdef->{atoms_vmd}->[0]\" frame \$i] get z]] [list $cdef->{origX} $cdef->{origY} $cdef->{origZ}]]\n";
      } elsif (uc($cdef->{type}) eq "AXISDIST") {
        $measure .= "\tputs \$outfile " . vmdAxisDistance($cdef->{atoms_vmd}->[0], $cdef->{axisA}->[0], $cdef->{axisA}->[1], $cdef->{axisA}->[2], $cdef->{axisB}->[0], $cdef->{axisB}->[1], $cdef->{axisB}->[2]) . "\n";
      } elsif (uc($cdef->{type}) eq "PLANEDIST") {
        $measure .= "\tputs \$outfile " . vmdPlaneDistance($cdef->{atoms_vmd}->[0], $cdef->{planePoint}->[0], $cdef->{planePoint}->[1], $cdef->{planePoint}->[2], $cdef->{planeNorm}->[0], $cdef->{planeNorm}->[1], $cdef->{planeNorm}->[2]) . "\n";
      } elsif (uc($cdef->{type}) eq "ANGL") {
        $measure .= "\tputs \$outfile \"[measure angle [list $ai{$cdef->{atoms_vmd}->[0]} $ai{$cdef->{atoms_vmd}->[1]} $ai{$cdef->{atoms_vmd}->[2]}] frame \$i]\"\n";
      } else {
        GENERAL::error("Unrecognized phase-space coordinate type '$cdef->{type}'");
      }
    }

    # VMD script to output desired coordinates in all frames
    $par{FIRSTF} = 1 if (!defined($par{FIRSTF}));
    my $vmd_scr;
    if (defined($self->getParameterValue("structure", "structure"))) {
      $vmd_scr = "mol load psf " . $self->getParameterValue("structure", "structure") . "\n";
    } else {
      $vmd_scr = "mol load pdb " . $self->getParameterValue("structure", "coordinates") . "\n";
    }
    foreach my $trajf (@trajf) { $vmd_scr .= "mol addfile $trajf type dcd waitfor all\n"; }
    $vmd_scr .= "set outfile [open $cref w]\n";
    $vmd_scr .= "set nf [molinfo top get numframes]\n";
    $vmd_scr .= "$getinds\n";
    $vmd_scr .= "for { set i " . ($par{FIRSTF}-1) . " } { \$i < \$nf } { incr i } {\n";
    $vmd_scr .= "  \tputs \$outfile \$i\n";
    $vmd_scr .= "  $measure\n";
    $vmd_scr .= "}\n";
    $vmd_scr .= "close \$outfile\nexit\n";

    # save VMD script and run VMD
    my $tmppgn = "_$$\_tmp_pdb_psf.pgn";
    my $ofh = GENERAL::GetOutFH($tmppgn);
    $ofh->printf("$vmd_scr");
    close($ofh);
    NAMD::runVMD($tmppgn);

    # read results and fill arrays
    my $arr = GENERAL::file2array($cref);
    # array of arrays that will hold all coordinate value/snapshots, first by coordinate then by snapshot
    my @C = GENERAL::ones(scalar(@$Cdef), 0);
    for (my $i = 0; $i < scalar(@$Cdef); $i++) {
      my @arr; tie @arr, TieArrayC => "double";
      $C[$i] = \@arr;
    }
    while (1) {
      last if (scalar(@$arr) == 0);
      my $fi = shift @$arr; # frame index
      GENERAL::assert(GENERAL::isInteger($fi), "Frame index read from $cref is '$fi', not an integer");

      # -- phase-space coordinates
      my @c;
      for (my $ci = 0; $ci < scalar(@$Cdef); $ci++) {
        my $cdef = $Cdef->[$ci];
        my $line = shift @$arr;
        my @line = split(" ", $line);
        if ((uc($cdef->{type}) eq "DIHE") || (uc($cdef->{type}) eq "IMPR") || (uc($cdef->{type}) eq "DIST") || (uc($cdef->{type}) eq "INPLACEDIST") || (uc($cdef->{type}) eq "ANGL")) {
          GENERAL::assert(scalar(@line) == 1, "Expected only one value in $cdef->{type} line of output file $cref '$line'...");
          push(@{$C[$ci]}, $line[0] + 0.0);
        } else {
          GENERAL::error("Unrecognized phase-space coordinate type '$cdef->{type}'");
        }
      }
    }

    # error check
    if (defined($ret{ener})) {
      GENERAL::assert(scalar(@{$ret{ener}}) == scalar(@{$C[0]}), sprintf("Read %d snapshot energies and %d snapshot coordinate sets!", scalar(@{$ret{ener}}), scalar(@C)));
    }

    # clean up
    GENERAL::crm($tmppgn, $cref);

    $ret{C} = \@C;
  } else {
    my @C; $ret{C} = \@C;
  }

  return \%ret;
}

sub vmdPlaneDistance {
  my $atomSel = shift;
  my $Px = shift;
  my $Py = shift;
  my $Pz = shift;
  my $Nx = shift;
  my $Ny = shift;
  my $Nz = shift;

  return "[expr {abs([vecdot [list [expr [[atomselect top \"$atomSel\" frame \$i] get x] - $Px]  ".
                       "[expr [[atomselect top \"$atomSel\" frame \$i] get y] - $Py]  ".
                       "[expr [[atomselect top \"$atomSel\" frame \$i] get z] - $Pz]] ".
                       "[vecnorm {$Nx $Ny $Nz}]])}]"
}

sub vmdAxisDistance {
  my $atomSel = shift;
  my $Ax = shift;
  my $Ay = shift;
  my $Az = shift;
  my $Bx = shift;
  my $By = shift;
  my $Bz = shift;
  my $pD = vmdPlaneDistance($atomSel, $Ax, $Ay, $Az, $Bx - $Ax, $By - $Ay, $Bz - $Az);
  return "[expr {sqrt(pow([veclength [list [expr [[atomselect top \"$atomSel\" frame \$i] get x] - $Ax]  ".
                                   "[expr [[atomselect top \"$atomSel\" frame \$i] get y] - $Ay]  ".
                                   "[expr [[atomselect top \"$atomSel\" frame \$i] get z] - $Az]]], 2) - pow($pD, 2))}]";
}

=head2

 Title   :  getCoordinatesVMD
 Usage   :  $namd->getCoordinatesVMD('CDEF', \@Cdef);
            NAMD::getCoordinatesVMD(undef, 'CDEF', \@Cdef);
 Function:  Analyzes the given trajectory and returns various geometric variables.
 Returns :  A hash reference representing the sought variables.
 Args    :  1. NAMD structure or undef if calling not with a NAMD object
            2-x. A list of parameter name/parameter value pairs. The following parameter names are possible:
            CDEF    - array reference, definition of coordinates to fish out. Required if not calling with a NAMD object, optional otherwise.
            TRAJ    - a string, space separated list of DCD files to load as the trajectory (will be loaded one at a time). Required if not calling with a NAMD object, optional otherwise.
            PSF     - psf file of the structure. Required if not calling with a NAMD object, optional otherwise.
            FIRSTF  - optional: integer, the first frame of interest of the trajectory
            STEP    - optional: stride for reading the trajectory (i.e., read every STEP-th frame)
            TMPDIR  - optional: path to a directory to be used for temporary IO

=cut

sub getCoordinatesVMD {
  my $self = shift;
  my %par = @_;
  GENERAL::assert(defined($par{CDEF}) && defined($par{TRAJ}) && defined($par{PSF}), "CDEF, TRAJ and PSF must be defined if not calling with a NAMD object") if (!defined($self));
  $par{STEP} = 1 if (!defined($par{STEP}));
  $par{FIRSTF} = 0 if (!defined($par{FIRSTF}));
  $par{TMPDIR} = "." if (!defined($par{TMPDIR}));

  my $Cdef = $par{CDEF}; # definitions of phase space-defining coordinates
  $Cdef = $self->getRestraints() if (!defined($Cdef));
  my $psff = $par{PSF};
  $psff = $self->getParameterValue("structure", "structure") if (!defined($psff));

  # trajectory files
  my @trajf;
  if (defined($par{TRAJ})) { @trajf = split(" ", GENERAL::Trim($par{TRAJ})); }
  else {
    # default DCD naming, if not specified
    push(@trajf, $self->getParameterValue("variables", "set outname") . ".dcd");
    for (my $i = 1; $i < $self->{run}; $i++) {
      push(@trajf, $self->getParameterValue("variables", "set outname") . "-r$i.dcd");
    }
  }

  my @C;
  # portion of VMD script that will measure the individual coordinates
  if (defined($Cdef) && (scalar(@$Cdef) > 0)) {
    my $cref = "$par{TMPDIR}/_ef_tmp.dat";
    my $measure = "";
    my $getinds = ""; my (%ai, %as); my $k = 1;


    foreach my $cdef (@$Cdef) {
      # first, get all necessary atom indices
      for (my $i = 0; $i < scalar(@{$cdef->{atoms_vmd}}); $i++) {
        my $astr = $cdef->{atoms_vmd}->[$i];
        next if (defined($ai{$astr}));
        $as{$astr} = "s$k"; $getinds .= "set $as{$astr} [atomselect top \"$astr\"]\n"; $as{$astr} = "\$$as{$astr}";
        $ai{$astr} = "i$k"; $getinds .= "set $ai{$astr} [$as{$astr} get index]\n"; $ai{$astr} = "\$$ai{$astr}";
        $k++;
      }
      if (uc($cdef->{type}) =~ /^(DIHE|IMPR)$/) {
        $measure .= "\tputs \$outfile \"[measure dihed [list $ai{$cdef->{atoms_vmd}->[0]} $ai{$cdef->{atoms_vmd}->[1]} $ai{$cdef->{atoms_vmd}->[2]} $ai{$cdef->{atoms_vmd}->[3]}] frame \$i]\"\n";
      } elsif (uc($cdef->{type}) eq "DIST") {
        $measure .= "\tputs \$outfile \"[measure bond [list $ai{$cdef->{atoms_vmd}->[0]} $ai{$cdef->{atoms_vmd}->[1]}] frame \$i]\"\n";
      } elsif (uc($cdef->{type}) eq "INPLACEDIST") {
        # ATTENTION: can be made faster by pre-storing x, y, and z of all relevant atoms
        $measure .= "\t$as{$cdef->{atoms_vmd}->[0]} frame \$i\n\t$as{$cdef->{atoms_vmd}->[0]} update\n";
        $measure .= "\tputs \$outfile [vecdist [list [$as{$cdef->{atoms_vmd}->[0]} get x] ".
                                                    "[$as{$cdef->{atoms_vmd}->[0]} get y] ".
                                                    "[$as{$cdef->{atoms_vmd}->[0]} get z]] [list $cdef->{origX} $cdef->{origY} $cdef->{origZ}]]\n";
      } elsif (uc($cdef->{type}) eq "AXISDIST") {
        $measure .= "\tputs \$outfile " . vmdAxisDistance($cdef->{atoms_vmd}->[0], $cdef->{axisA}->[0], $cdef->{axisA}->[1], $cdef->{axisA}->[2], $cdef->{axisB}->[0], $cdef->{axisB}->[1], $cdef->{axisB}->[2]) . "\n";
      } elsif (uc($cdef->{type}) eq "PLANEDIST") {
        $measure .= "\tputs \$outfile " . vmdPlaneDistance($cdef->{atoms_vmd}->[0], $cdef->{planePoint}->[0], $cdef->{planePoint}->[1], $cdef->{planePoint}->[2], $cdef->{planeNorm}->[0], $cdef->{planeNorm}->[1], $cdef->{planeNorm}->[2]) . "\n";
      } elsif (uc($cdef->{type}) eq "ANGL") {
        $measure .= "\tputs \$outfile \"[measure angle [list $ai{$cdef->{atoms_vmd}->[0]} $ai{$cdef->{atoms_vmd}->[1]} $ai{$cdef->{atoms_vmd}->[2]}] frame \$i]\"\n";
      } else {
        GENERAL::error("Unrecognized phase-space coordinate type '$cdef->{type}'");
      }
    }

    # VMD script to output desired coordinates in all frames
    my $vmd_scr = "mol load psf $psff\n";
    foreach my $trajf (@trajf) { $vmd_scr .= "mol addfile $trajf type dcd step $par{STEP} first $par{FIRSTF} waitfor all\n"; }
    $vmd_scr .= "set outfile [open $cref w]\n";
    $vmd_scr .= "set nf [molinfo top get numframes]\n";
    $vmd_scr .= "$getinds\n";
    $vmd_scr .= "for { set i 0 } { \$i < \$nf } { incr i } {\n";
    $vmd_scr .= "  \tputs \$outfile \$i\n";
    $vmd_scr .= "  $measure\n";
    $vmd_scr .= "}\n";
    $vmd_scr .= "close \$outfile\nexit\n";

    # save VMD script and run VMD
    my $tmppgn = "$par{TMPDIR}/_$$\_tmp_pdb_psf.pgn";
    my $ofh = GENERAL::GetOutFH($tmppgn);
    $ofh->printf("$vmd_scr");
    close($ofh);
    NAMD::runVMD($tmppgn);

    # array of arrays that will hold all coordinate value/snapshots, first by coordinate then by snapshot
    @C = GENERAL::ones(scalar(@$Cdef), 0);
    for (my $i = 0; $i < scalar(@$Cdef); $i++) {
      my @arr; tie @arr, TieArrayC => "double";
      $C[$i] = \@arr;
    }

    # read results and fill arrays
    my $ifh = GENERAL::GetInFH($cref);
    while (1) {
      my $fi = <$ifh>; # frame index
      last if (!defined($fi));
      GENERAL::assert(GENERAL::isInteger($fi), "Frame index read from $cref is '$fi', not an integer");

      # -- phase-space coordinates
      my @c;
      for (my $ci = 0; $ci < scalar(@$Cdef); $ci++) {
        my $cdef = $Cdef->[$ci];
        my $line = <$ifh>; GENERAL::assert(defined($line), "reached the end of file '$cref' prematurely");
        my @line = split(" ", $line);
        if ((uc($cdef->{type}) eq "DIHE") || (uc($cdef->{type}) eq "IMPR") || (uc($cdef->{type}) eq "DIST") || (uc($cdef->{type}) eq "INPLACEDIST") || (uc($cdef->{type}) eq "PLANEDIST") || (uc($cdef->{type}) eq "AXISDIST") || (uc($cdef->{type}) eq "ANGL")) {
          GENERAL::assert(scalar(@line) == 1, "Expected only one value in $cdef->{type} line of output file $cref '$line'...");
          push(@{$C[$ci]}, $line[0] + 0.0);
        } else {
          GENERAL::error("Unrecognized phase-space coordinate type '$cdef->{type}'");
        }
      }
    }
    close($ifh);

    # clean up
    GENERAL::crm($tmppgn, $cref);
  }

  return \@C;
}

=head2

 Title   :  saveFrames
 Usage   :  $namd->saveFrmes("traj.dcd", "struct.psf", "out", 1, 10);
 Function:  Writes out select frames from a DCD trajectory into PDB files.
 Returns :  Nothing.
 Args    :  1. Trajectory DCD file
            2. PSF file
            3. Output base name
            4. First frame to consider (0-initiated index);
            5. Last frame to consider (0-initiated index)
            6. Increment. Will write out all frames with indices F + n*I <= L, where F is the first index, I is the increment, L is the last index, and n >= 0
            7. optional: VMD selection (by default saves the entire frame)

=cut

sub saveFrames {
  my $dcd = shift;
  my $psf = shift;
  my $outBase = shift;
  my $beg = shift;
  my $end = shift;
  my $inc = shift; $inc = 1 if (!defined($inc));
  my $sel = shift; $sel = "all" if (!defined($sel));

  my $tmpf = "_dcd2pdb1_$$.vmd";
  my $ofh = GENERAL::GetOutFH($tmpf);
  $ofh->printf("set end $end\n");
  $ofh->printf("set beg $beg\n");
  $ofh->printf("mol load psf $psf dcd $dcd\n");
  $ofh->printf("set nf [molinfo top get numframes]\n");
  $ofh->printf("if {(\$nf <= \$end) || (\$end < 0)} {\n");
  $ofh->printf("  set end [expr \$nf-1]\n");
  $ofh->printf("}\n");
  $ofh->printf("if {\$beg < 0} {\n");
  $ofh->printf("  set beg \$end\n");
  $ofh->printf("}\n");
  $ofh->printf("for {set i \$beg} {\$i <= \$end} {incr i $inc} {\n");
  if ($beg ne $end) {
    $ofh->printf("   [atomselect top $sel frame \$i] writepdb $outBase\_\$i.pdb\n");
  } else {
    $ofh->printf("   [atomselect top $sel frame \$i] writepdb $outBase.pdb\n");
  }
  $ofh->printf("}\n");
  $ofh->printf("exit\n");
  close($ofh);

  NAMD::runVMD($tmpf);
  GENERAL::crm($tmpf);
}


=head2

 Title   :  getNumFrames
 Usage   :  NAMD::getNumFrmes("traj.dcd");
 Function:  returns the number of complete frames actually stored in the DCD file
 Returns :  the number of complete frames actually stored in the DCD file
 Args    :  1. Trajectory DCD file

=cut

sub getNumFrames {
  my $DCD = shift;
  my $base = "/tmp/getnumframes_$$." . GENERAL::GetMachine();
  my $tmptcl = "$base.vmd";
  my $tmpof = "$base.out";
  my $ofh = GENERAL::GetOutFH($tmptcl);
  $ofh->printf("mol load dcd $DCD\nset nf [molinfo top get numframes]\nputs numframes=\$nf\nexit\n");
  close($ofh);
  NAMD::runVMD($tmptcl, "output", $tmpof, "keep_output", 1);
  my $lines = GENERAL::file2array($tmpof);
  my $n;
  foreach my $line (@$lines) {
    next if ($line !~ /numframes=(\d+)$/);
    $n = $1;
    last;
  }
  GENERAL::error("number of frames not found in output of '$tmptcl' (in '$tmpof')") if (!defined($n));
  GENERAL::crm($tmptcl, $tmpof);
  return $n;
}


=head2  mergeTrajectories

 Title   :  mergeTrajectories
 Usage   :  NAMD::mergeTrajectories("all.dcd", "first.dcd", "second.dcd", ...)
 Function:  merges the specified trajectories into one
 Returns :  nothing
 Args    :  1. Output trajectory name
            2-n. Individual smaller trajectory names

=cut

sub mergeTrajectories {
  my $outDCD = shift;
  my @inDCD = @_;
  GENERAL::error("empty list of input trajectories passed") if (scalar(@inDCD) == 0);

  my $base = "/tmp/mergetraj_$$." . GENERAL::GetMachine();
  my $tmptcl = "$base.vmd";
  my $ofh = GENERAL::GetOutFH($tmptcl);
  for (my $i = 0; $i < scalar(@inDCD); $i++) {
    if ($i == 0) {
      $ofh->printf("mol load dcd $inDCD[$i]\n");
    } else {
      $ofh->printf("mol addfile $inDCD[$i] type dcd waitfor all\n");
    }
  }
  $ofh->printf("set N [expr [molinfo top get numframes] - 1]\n");
  $ofh->printf("animate write dcd $outDCD beg 0 end \$N skip 1 waitfor all top\n");
  $ofh->printf("exit\n");
  close($ofh);
  NAMD::runVMD($tmptcl);
}


=head2

 Title   :  parsePSF
 Usage   :  my $psf = NAMD::parsePSF("file.psf");
 Function:  Parses the PSF to get information about bonds, angles, dihedrals and impropers.
 Returns :  Hash structure with the parsed PSF.
 Args    :  1. PSF file
            2. optional: PDB object. If specifies, cross-references atoms in the PSF with PDB atoms.

=cut

sub parsePSF {
  my $psff = shift;
  GENERAL::requireArgs($psff);
  my $pdb = shift;
  my (@S, @B, @A, @D, @I, @C);
  my %psf; my $k = 0;

  my $fh = GENERAL::GetInFH($psff);
  # get structure info (atoms and types)
  GENERAL::skipTo($fh, "NATOM");
  while (<$fh>) {
    last if (/NBOND/);
    my $line =  GENERAL::Trim($_);
    next if ($line eq "");
    my @line = split(" ", $line);
    my %atom;
    $atom{psfline} = \@line;
    $atom{psfstring} = $line;
    $atom{tclSel} = "$line[1] $line[2] $line[4]";
    $atom{vmdSel} = "segid $line[1] and resid $line[2] and name $line[4]";
    $atom{charmmSel} = "segid $line[1] .and. resid $line[2] .and. type $line[4]";
    $atom{resname} = $line[3];
    $atom{resnum} = $line[2];
    $atom{name} = $line[4];
    $atom{segname} = $line[1];
    $atom{type} = $line[5];
    $atom{inx} = $line[0]-1;
    $atom{pdbatom} = PDB::getAtomInRes($pdb->getResByInd($atom{segname}, $atom{resnum}), $atom{name}) if (defined($pdb));
    push(@S, \%atom);
    $k++;
  }

  # get bonds
  while (<$fh>) {
    last if (/NTHETA/);
    my $line =  GENERAL::Trim($_);
    next if ($line eq "");
    my @line = split(" ", $line);
    GENERAL::assert(scalar(@line) % 2 == 0, "unexpected number of elements in PSF bond line '$line'");
    for (my $i = 0; $i < scalar(@line); $i += 2) {
      my @s = ($line[$i]-1, $line[$i+1]-1);
      push(@B, \@s);
    }
  }

  # get angles
  while (<$fh>) {
    last if (/NPHI/);
    my $line =  GENERAL::Trim($_);
    next if ($line eq "");
    my @line = split(" ", $line);
    GENERAL::assert(scalar(@line) % 3 == 0, "unexpected number of elements in PSF angle line '$line'");
    for (my $i = 0; $i < scalar(@line); $i += 3) {
      my @s = ($line[$i]-1, $line[$i+1]-1, $line[$i+2]-1);
      push(@A, \@s);
    }
  }

  # get dihedrals
  while (<$fh>) {
    last if (/NIMPHI/);
    my $line =  GENERAL::Trim($_);
    next if ($line eq "");
    my @line = split(" ", $line);
    GENERAL::assert(scalar(@line) % 4 == 0, "unexpected number of elements in PSF dihedral line '$line'");
    for (my $i = 0; $i < scalar(@line); $i += 4) {
      my @s = ($line[$i]-1, $line[$i+1]-1, $line[$i+2]-1, $line[$i+3]-1);
      push(@D, \@s);
    }
  }

  # get impropers
  while (<$fh>) {
    last if (/NDON/);
    my $line =  GENERAL::Trim($_);
    next if ($line eq "");
    my @line = split(" ", $line);
    GENERAL::assert(scalar(@line) % 4 == 0, "unexpected number of elements in PSF improper line '$line'");
    for (my $i = 0; $i < scalar(@line); $i += 4) {
      my @s = ($line[$i]-1, $line[$i+1]-1, $line[$i+2]-1, $line[$i+3]-1);
      push(@I, \@s);
    }
  }
  close($fh);

  # figure out connected components
  # -- first, each atom starts out in a component by itself
  my (%A, %C); $k = 0;
  foreach my $a (@S) {
    my @tmp = ($a->{inx});
    $C{$k} = \@tmp;
    $A{$a->{psfstring}} = $k;
    $k++;
  }
  foreach my $b (@B) {
    my $ai = $S[$b->[0]];
    my $aj = $S[$b->[1]];
    my $ci = $A{$ai->{psfstring}};
    my $cj = $A{$aj->{psfstring}};
    # -- join the two components the atoms are in, unless they are already in the same component
    next if ($ci == $cj);
    foreach my $inx (@{$C{$cj}}) {
      $A{$S[$inx]->{psfstring}} = $ci;
    }
    push(@{$C{$ci}}, @{$C{$cj}});
    delete($C{$cj});
  }
  foreach my $k (keys(%C)) {
    push(@C, $C{$k});
  }

  $psf{atoms} = \@S;
  $psf{bonds} = \@B;
  $psf{angles} = \@A;
  $psf{dihedrals} = \@D;
  $psf{impropers} = \@I;
  $psf{connComps} = \@C;

  return \%psf;
}

=head2

 Title   :  generateBAT
 Usage   :  my $psf = NAMD::generateBAT($psf, "C", "H1", "H2");
 Function:  Returns a set of bonds, bond angles and torsional angles that together define
            a BAT internal coordinate system for the system (assumes it's a single molecule),
            or just the given part of it (e.g. corresponding to an individual molecule).
 Returns :  Three array references for bonds, angles, and torsions
 Args    :  1. PSF structure
            2-4. Three atom names of seed atoms. By default, seeds on the first atom, plus some
                 atom bonded to it, plus another atom bonded to that one
            5. Optional: array reference of atom indices (into the $psf->{atoms} array),
               defining the system to create a BAT coordinate set for.
            6. Optional: additional named parameters, specified as 'name', 'value' pairs.
               Currently supported parameters are:
               'useDihedrals' -- in building the BAT set, make sure to use the dihedral angles,
                                 specified as an array of dihedral names (each being an array
                                 of four atom names, e.g. ('A 1 C', 'A 1 N', 'A 1 CA', 'A 2 N'))
               'useParamICs'  -- given a CHARMM parameter hash, returned by CHARMM::readCHARMMParameters,
                                 make sure that the bonds, bond angles and dihedrals used in the
                                 BAT not only are present in the PSF, but also correspond to valid
                                 parameters in the force-field. This is useful because sometimes
                                 the PSF contains some "pseudo-parameters" (such as for TIP3 water).

=cut

sub generateBAT {
  my $psf = shift;
  GENERAL::requireArgs($psf);
  my $an1 = shift;
  my $an2 = shift;
  my $an3 = shift;
  my $ai = shift;
  if (!defined($ai)) { my @tmp = GENERAL::linspace(0, scalar(@{$psf->{atoms}})-1, 1); $ai = \@tmp; } # do the entire system by default
  my %opts = @_;
  $opts{verbose} = 1 if (!defined($opts{verbose}));
  my $placeOp = $opts{placementOperations} if (defined($opts{placementOperations}));

  my (@bonds, @angles, @torsions);

  # create hashes of atoms, bonds, angles, dihedrals and impropers by atom name
  my (@ats, %ats, %B, %A, %D, %I);
  foreach my $i (@$ai) {
    push(@ats, $psf->{atoms}->[$i]->{tclSel});
    $ats{$psf->{atoms}->[$i]->{tclSel}} = $i;
  }
  if (scalar(@ats) == 0) { return ((),(),()); }
  foreach my $ent (@{$psf->{bonds}}) {
    next if (defined($opts{'useParamICs'}) && (!defined(CHARMM::getBondPar($opts{'useParamICs'}, $psf->{atoms}->[$ent->[0]]->{type}, $psf->{atoms}->[$ent->[1]]->{type}, -1))));
    $B{$psf->{atoms}->[$ent->[0]]->{tclSel}}{$psf->{atoms}->[$ent->[1]]->{tclSel}} = $ent;
    $B{$psf->{atoms}->[$ent->[1]]->{tclSel}}{$psf->{atoms}->[$ent->[0]]->{tclSel}} = $ent;
  }
  foreach my $ent (@{$psf->{angles}}) {
    next if (defined($opts{'useParamICs'}) && (!defined(CHARMM::getAnglPar($opts{'useParamICs'}, $psf->{atoms}->[$ent->[0]]->{type}, $psf->{atoms}->[$ent->[1]]->{type}, $psf->{atoms}->[$ent->[2]]->{type}, -1))));
    $A{$psf->{atoms}->[$ent->[0]]->{tclSel}}{$psf->{atoms}->[$ent->[1]]->{tclSel}}{$psf->{atoms}->[$ent->[2]]->{tclSel}} = $ent;
    $A{$psf->{atoms}->[$ent->[2]]->{tclSel}}{$psf->{atoms}->[$ent->[1]]->{tclSel}}{$psf->{atoms}->[$ent->[0]]->{tclSel}} = $ent;
  }
  foreach my $ent (@{$psf->{dihedrals}}) {
    next if (defined($opts{'useParamICs'}) && (!defined(CHARMM::getDihePar($opts{'useParamICs'}, $psf->{atoms}->[$ent->[0]]->{type}, $psf->{atoms}->[$ent->[1]]->{type}, $psf->{atoms}->[$ent->[2]]->{type}, $psf->{atoms}->[$ent->[3]]->{type}, -1))));
    $D{$psf->{atoms}->[$ent->[0]]->{tclSel}}{$psf->{atoms}->[$ent->[1]]->{tclSel}}{$psf->{atoms}->[$ent->[2]]->{tclSel}}{$psf->{atoms}->[$ent->[3]]->{tclSel}} = $ent;
    $D{$psf->{atoms}->[$ent->[3]]->{tclSel}}{$psf->{atoms}->[$ent->[2]]->{tclSel}}{$psf->{atoms}->[$ent->[1]]->{tclSel}}{$psf->{atoms}->[$ent->[0]]->{tclSel}} = $ent;
  }
  foreach my $ent (@{$psf->{impropers}}) {
    next if (defined($opts{'useParamICs'}) && (!defined(CHARMM::getImprPar($opts{'useParamICs'}, $psf->{atoms}->[$ent->[0]]->{type}, $psf->{atoms}->[$ent->[1]]->{type}, $psf->{atoms}->[$ent->[2]]->{type}, $psf->{atoms}->[$ent->[3]]->{type}, -1))));
    $I{$psf->{atoms}->[$ent->[0]]->{tclSel}}{$psf->{atoms}->[$ent->[1]]->{tclSel}}{$psf->{atoms}->[$ent->[2]]->{tclSel}}{$psf->{atoms}->[$ent->[3]]->{tclSel}} = $ent;
    $I{$psf->{atoms}->[$ent->[3]]->{tclSel}}{$psf->{atoms}->[$ent->[2]]->{tclSel}}{$psf->{atoms}->[$ent->[1]]->{tclSel}}{$psf->{atoms}->[$ent->[0]]->{tclSel}} = $ent;
  }

  # if seeds not defined, look for something to seed on
  if (!defined($an1)) {
    if (defined($opts{useDihedrals}) && (scalar(@{$opts{useDihedrals}}) > 0)) {
      $an1 = $opts{useDihedrals}->[0]->[0];
      $an2 = $opts{useDihedrals}->[0]->[1];
      $an3 = $opts{useDihedrals}->[0]->[2];
    } else {
      $an1 = undef; $an2 = undef; $an3 = undef;
      # try every atom as a potential first seed atom
      foreach my $at (@ats) {
        $an1 = $at;
        if (scalar(@ats) > 1) {
          # try every atom the first atom is bonded to as a potential second seed
          foreach my $tan2 (keys(%{$B{$an1}})) {
            $an2 = $tan2;
            if (scalar(@ats) > 2) {
              # any atom completing an angle with the first two potential seeds, completes the three seed atoms
              foreach my $tan3 (keys(%{$A{$an1}{$an2}})) {
                $an3 = $tan3;
                last;
              }
              next if (!defined($an3));
            }
            last;
          }
          next if (!defined($an3));
        }
        last;
      }
    }

    GENERAL::assert(defined($an1), "Could not automatically find first atom to seed on!");
    GENERAL::assert(defined($an2), "Could not automatically find second atom to seed on!") if (scalar(@ats) > 1);
    GENERAL::assert(defined($an3), "Could not automatically find third atom to seed on!") if (scalar(@ats) > 2);
  }

  # add coordinates of first three atoms
  my @placed = ($an1); if (defined($placeOp)) { my @tmp = ($ats{$an1}); push(@$placeOp, \@tmp); }
  if (scalar(@ats) > 1) {
    GENERAL::assert(defined($B{$an1}{$an2}), "Bond between seed atoms $an1 - $an2 not found"); push(@bonds, $B{$an1}{$an2});
    push(@placed, $an2); if (defined($placeOp)) { my @tmp = ($ats{$an2}, $ats{$an1}); push(@$placeOp, \@tmp); }
  }
  if (scalar(@ats) > 2) {
    GENERAL::assert(defined($B{$an2}{$an3}), "Bond between seed atoms $an2 - $an3 not found"); push(@bonds, $B{$an2}{$an3});
    GENERAL::assert(defined($A{$an1}{$an2}{$an3}), "Angle between seed atoms $an1 - $an2 - $an3 not found"); push(@angles, $A{$an1}{$an2}{$an3});
    push(@placed, $an3); if (defined($placeOp)) { my @tmp = ($ats{$an3}, $ats{$an2}, $ats{$an1}); push(@$placeOp, \@tmp); }
  }

  # "place" all remaining atoms and record the necessary BAT coordinates
  my @rem = GENERAL::setdiff(\@ats, \@placed);
  GENERAL::assert(scalar(@rem) == scalar(@ats) - scalar(@placed), sprintf("Not all seed atoms (%s, %s, %s) found in PSF!", defined($an1) ? $an1 : "NONE", defined($an2) ? $an2 : "NONE", defined($an3) ? $an3 : "NONE"));
  my (%placed, %rem);
  foreach my $a (@placed) { $placed{$a} = 1; }
  foreach my $a (@rem) { $rem{$a} = 1; }

  # first, if we are asked to use a certain set of dihedrals, use them first to place as many atoms as possible
  if (defined($opts{useDihedrals})) {
    my @dihedralUsed = GENERAL::ones(scalar(@{$opts{useDihedrals}}), 0);
    while (1) {
      my $f = 0;
      my @wouldHelpToPlace;
      # look for a dihedral with three terminal atoms already placed
      for (my $di = 0; $di < scalar(@{$opts{useDihedrals}}); $di++) {
        my $dihe = $opts{useDihedrals}->[$di];
        my ($na, $a, $aa, $da);
        if (defined($placed{$dihe->[0]}) && defined($placed{$dihe->[1]}) && defined($placed{$dihe->[2]}) && !defined($placed{$dihe->[3]})) {
          $na = $dihe->[3]; $a = $dihe->[2]; $aa = $dihe->[1]; $da = $dihe->[0];
        } elsif (!defined($placed{$dihe->[0]}) && defined($placed{$dihe->[1]}) && defined($placed{$dihe->[2]}) && defined($placed{$dihe->[3]})) {
          $na = $dihe->[0]; $a = $dihe->[1]; $aa = $dihe->[2]; $da = $dihe->[3];
        } else {
          next;
        }
        $f++;
        $dihedralUsed[$di] = 1;
        # add bond, angle, dihedral
        my @bond = ($ats{$a}, $ats{$na}); push(@bonds, \@bond);
        my @angl = ($ats{$aa}, $ats{$a}, $ats{$na}); push(@angles, \@angl);
        my @tor = ($ats{$da}, $ats{$aa}, $ats{$a}, $ats{$na}); push(@torsions, \@tor);
        if (defined($placeOp)) { my @tmp = ($ats{$na}, $ats{$a}, $ats{$aa}, $ats{$da}); push(@$placeOp, \@tmp); } # record how to build the structure
        push(@placed, $na);
        $placed{$na} = 1; delete($rem{$na});
        @rem = GENERAL::setdiff(\@ats, \@placed);
      }
      last if ($f == 0);
    }
    if (GENERAL::sum(@dihedralUsed) != scalar(@{$opts{useDihedrals}})) {
      printf("it seems that not all stipulated dihedrals could be used for placing atoms!\n");
      for (my $di = 0; $di < scalar(@{$opts{useDihedrals}}); $di++) {
        my $dihe = $opts{useDihedrals}->[$di];
        printf("DIHE $dihe->[0] $dihe->[1] $dihe->[2] $dihe->[3] %s\n", $dihedralUsed[$di] ? "used" : "NOT used");
      }
      GENERAL::error("this is a fatal problem...\n");
    }
  }

  # then, place all remaining atoms best you can
  while (scalar(@rem) != 0) {
    my $f = 0;
    foreach my $allow_new_torsion (0, 1) {  # first try to place something without making up any new dihedrals

      foreach my $na (@rem) {
        # find a placed atoms bound to this unplaced atom
        foreach my $a (keys(%{$B{$na}})) {
          next if (!defined($placed{$a}));
          # find an angle between this atom, the already placed atom before, and some other placed atom
          foreach my $aa (keys(%{$A{$na}{$a}})) {
            next if (!defined($placed{$aa}));
            # find a dihedral angle between this atom, the two already placed atoms, and some other placed atom
            foreach my $da (keys(%{$D{$na}{$a}{$aa}})) {
              next if (!defined($placed{$aa}));
              $f = 1;
              # add bond, angle, dihedral
              push(@bonds, $B{$a}{$na});
              push(@angles, $A{$na}{$a}{$aa});
              push(@torsions, $D{$na}{$a}{$aa}{$da});
              if (defined($placeOp)) { my @tmp = ($ats{$na}, $ats{$a}, $ats{$aa}, $ats{$da}); push(@$placeOp, \@tmp); } # record how to build the structure
              push(@placed, $na);
              $placed{$na} = 1; delete($rem{$na});
              last;
            }
            last if ($f == 1);
            # OR find an improper dihedral angle between this atom, the two already placed atoms, and some other placed atom
            foreach my $da (keys(%{$I{$na}{$a}{$aa}})) {
              next if (!defined($placed{$da}));
              $f = 1;
              # add bond, angle, dihedral
              push(@bonds, $B{$a}{$na});
              push(@angles, $A{$na}{$a}{$aa});
              push(@torsions, $I{$na}{$a}{$aa}{$da});
              if (defined($placeOp)) { my @tmp = ($ats{$na}, $ats{$a}, $ats{$aa}, $ats{$da}); push(@$placeOp, \@tmp); } # record how to build the structure
              push(@placed, $na);
              $placed{$na} = 1; delete($rem{$na});
              last;
            }
            last if ($f == 1);
            next if ($allow_new_torsion == 0);
            # OR simply pick an atom bonded to any of the two already placed atoms, and make up a dihedral
            foreach my $da (keys(%{$B{$a}}), keys(%{$B{$aa}})) {
              next if ((!defined($placed{$da})) || ($da eq $aa) || ($da eq $a));
              $f = 1;
              # add bond, angle, dihedral
              push(@bonds, $B{$a}{$na});
              push(@angles, $A{$na}{$a}{$aa});
              my @tor = ($ats{$da}, $ats{$aa}, $ats{$a}, $ats{$na}); push(@torsions, \@tor);
              if (defined($placeOp)) { my @tmp = ($ats{$na}, $ats{$a}, $ats{$aa}, $ats{$da}); push(@$placeOp, \@tmp); } # record how to build the structure
              push(@placed, $na);
              $placed{$na} = 1; delete($rem{$na});
              last;
            }
            last if ($f == 1);
          }
          last if ($f == 1);
        }
        last if ($f == 1);
      }
      last if ($f == 1);
    }
    GENERAL::assert($f, "After placing atoms: [" . join(", ", @placed) . "], nothing else could be placed!");
    @rem = GENERAL::setdiff(\@ats, \@placed);
  }

  if ($opts{verbose}) {
    printf("BAT coordinate set:\n");
    foreach my $ent (@bonds) {
      printf("BOND %6s %6s\n", $psf->{atoms}->[$ent->[0]]->{tclSel}, $psf->{atoms}->[$ent->[1]]->{tclSel});
    }
    foreach my $ent (@angles) {
      printf("ANGL %6s %6s %6s\n", $psf->{atoms}->[$ent->[0]]->{tclSel}, $psf->{atoms}->[$ent->[1]]->{tclSel}, $psf->{atoms}->[$ent->[2]]->{tclSel});
    }
    foreach my $ent (@torsions) {
      printf("DIHE %6s %6s %6s %6s\n", $psf->{atoms}->[$ent->[0]]->{tclSel}, $psf->{atoms}->[$ent->[1]]->{tclSel}, $psf->{atoms}->[$ent->[2]]->{tclSel}, $psf->{atoms}->[$ent->[3]]->{tclSel});
    }
  }

  GENERAL::assert(scalar(@bonds) == scalar(@ats) - 1, "Unexpected number of bonds in BAT coordinate set for " . scalar(@ats) . " atoms!") if (scalar(@ats) > 1);
  GENERAL::assert(scalar(@angles) == scalar(@ats) - 2, "Unexpected number of angles in BAT coordinate set for " . scalar(@ats) . " atoms!") if (scalar(@ats) > 2);
  GENERAL::assert(scalar(@torsions) == scalar(@ats) - 3, "Unexpected number of torsions in BAT coordinate set for " . scalar(@ats) . " atoms!") if (scalar(@ats) > 3);

  return (\@bonds, \@angles, \@torsions);
}


sub _tryPlacingUsingBAT {
  my $na = shift;
  my $B = shift;
  my $A = shift;
  my $D = shift;
  my $placedH = shift;
  my $bonds = shift;
  my $angles = shift;
  my $torsions = shift;
  GENERAL::requireArgs($na, $B, $A, $D, $placedH, $bonds, $angles, $torsions);
  my $placedA = shift;
  my $rem = shift;

  # find a placed atoms bound to this unplaced atom
  my $f = 0;
  foreach my $a (keys(%{$B->{$na}})) {
    next if (!defined($placedH->{$a}));
    # find an angle between this atom, the already placed atom before, and some other placed atom
    foreach my $aa (keys(%{$A->{$na}{$a}})) {
      next if (!defined($placedH->{$aa}));
      # find a dihedral angle between this atom, the two already placed atoms, and some other placed atom
      foreach my $da (keys(%{$D->{$na}{$a}{$aa}})) {
        next if (!defined($placedH->{$aa}));
        $f = 1;
        # add bond, angle, dihedral
        push(@$bonds, $B->{$a}{$na});
        push(@$angles, $A->{$na}{$a}{$aa});
        push(@$torsions, $D->{$na}{$a}{$aa}{$da});
        push(@$placedA, $na) if (defined($placedA));
        $placedH->{$na} = 1; delete($rem->{$na}) if (defined($rem));
        last;
      }
    }
  }
  return $f;
}

=head2

 Title   :  vmdAtom
 Usage   :  my $sel = NAMD::vmdAtom($a);
 Function:  Given a PDB atom, returns a VMD selection string.
 Returns :
 Args    :  1. PDB atom

=cut

sub vmdAtom {
  my @ret;
  foreach my $a (@_) {
    push(@ret, "segid $a->{residue}->{chain}->{id} and resid $a->{residue}->{resnum} and name $a->{atomname}");
  }
  return @ret;
}

=head2

 Title   :  vmdRes
 Usage   :  my $sel = NAMD::vmdRes($res);
 Function:  Given a PDB residue, returns a VMD selection string.
 Returns :
 Args    :  1. PDB residue

=cut

sub vmdRes {
  my $res = shift;
  return "segid $res->{chain}->{id} and resid $res->{resnum}";
}

1;
